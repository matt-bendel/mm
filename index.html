<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Moonlit Bandanas — Game Hub</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Inter:wght@400;600&family=Crimson+Text:wght@400;700&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#0b0b0d; --panel:#131316; --ink:#ececf2; --muted:#a1a1aa;
    --accent:#b11226; --accent2:#e01e37; --ring:0 0 0 2px rgba(224,30,55,.25);
  }
  *{box-sizing:border-box} html,body{height:100%}
  body{
    margin:0;
    background:
      radial-gradient(1200px 600px at 80% -10%, rgba(224,30,55,.10), transparent 60%),
      radial-gradient(800px 500px at -10% 80%, rgba(224,30,55,.08), transparent 60%),
      var(--bg);
    color:var(--ink); font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif;
  }
  header{padding:28px 20px 8px; text-align:center}
  .title{font-family:Cinzel,serif; font-weight:700; font-size:clamp(26px,3.2vw,40px); text-shadow:0 0 30px rgba(224,30,55,.25)}
  .subtitle{color:var(--muted); margin-top:6px}
  .wrap{max-width:1100px; margin:0 auto; padding:20px}
  .tabs{display:flex; gap:8px; justify-content:center; margin:16px 0 24px; flex-wrap:wrap}
  .tabs.hidden{display:none !important}
  .tab{border:1px solid #26262b; background:#121215; color:#d7d7de; padding:10px 14px; border-radius:12px; cursor:pointer}
  .tab[aria-selected="true"]{background:#201116; border-color:#531018; color:#ffd9dd; box-shadow:0 0 24px rgba(177,18,38,.35)}
  .panel{background:linear-gradient(180deg,#121215,#0f0f12); border:1px solid #242428; border-radius:16px; padding:18px}
  .grid{display:grid; gap:16px}
  @media(min-width:980px){.grid-2{grid-template-columns:1.2fr .8fr}}
  label{display:block; font-weight:600; margin:12px 0 6px}
  input, textarea, select{
    width:100%; background:#0d0d10; border:1px solid #26262b; color:#ececf2; border-radius:12px; padding:10px 12px; outline:none; font-size:15px
  }
  input:focus,textarea:focus,select:focus{border-color:#5f101a; box-shadow:var(--ring)}
  textarea{min-height:140px; resize:vertical}
  .btn{display:inline-flex; gap:8px; align-items:center; justify-content:center; background:linear-gradient(180deg,var(--accent2),var(--accent)); color:#fff; border:none; padding:11px 16px; border-radius:12px; cursor:pointer; font-weight:700; box-shadow:0 6px 24px rgba(224,30,55,.25)}
  .btn.secondary{background:#17171b; color:#f0e9eb; border:1px solid #2a2a30; box-shadow:none; font-weight:600}
  .muted{color:var(--muted); font-size:13px}
  .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  .badge{display:inline-block; padding:6px 10px; border-radius:999px; border:1px solid #2a2a30; color:#ececf2; font-size:13px; background:#111114}
  .success{border-color:#224a2b; background:linear-gradient(180deg,#102114,#0d1610); color:#c5f2d1}
  .danger{border-color:#5a0c15; background:linear-gradient(180deg,#1c0b0d,#12080a); color:#ffd9de}
  .divider{height:1px; background:#222226; margin:14px 0}
  .card{background:linear-gradient(180deg,#121215,#0f0f12); border:1px solid #242428; border-radius:16px; padding:14px}
  .mono{font-family:ui-monospace,Menlo,Monaco,Consolas,monospace}
  .center{text-align:center}
  .pill{padding:6px 10px; border-radius:999px; background:#151518; border:1px solid #2a2a30; font-size:12px}

  /* Burned parchment for clues */
  .parchment{
    color:#20160f;
    border:1px solid #3a2a1f;
    border-radius:14px;
    padding:14px 16px;
    font-family:"Crimson Text","Times New Roman",serif;
    box-shadow:0 10px 30px rgba(0,0,0,.45), inset 0 0 24px rgba(0,0,0,.35);
    background:
      radial-gradient(140% 100% at 0% 0%, rgba(0,0,0,.18), transparent 40%),
      radial-gradient(140% 100% at 100% 100%, rgba(0,0,0,.16), transparent 40%),
      radial-gradient(200px 80px at 10% 20%, rgba(70,35,20,.35), transparent 60%),
      radial-gradient(200px 80px at 90% 80%, rgba(70,35,20,.30), transparent 60%),
      repeating-linear-gradient(0deg, rgba(0,0,0,.035), rgba(0,0,0,.035) 2px, transparent 2px, transparent 4px),
      linear-gradient(180deg, #3a2b1f, #2f231a 60%, #2b2118);
    position:relative;
  }
  .parchment:before{
    content:""; position:absolute; inset:-6px; border-radius:18px;
    background:
      radial-gradient(200px 60px at 5% 10%, rgba(0,0,0,.65), transparent 50%),
      radial-gradient(240px 80px at 95% 90%, rgba(0,0,0,.6), transparent 50%),
      radial-gradient(800px 220px at 50% -40px, rgba(0,0,0,.5), transparent 60%),
      radial-gradient(800px 220px at 50% calc(100% + 40px), rgba(0,0,0,.5), transparent 60%);
    pointer-events:none; mix-blend-mode:multiply; opacity:.6; filter: blur(1px);
  }
  .parchment h4{margin:.3rem 0 .2rem; font-size:18px; color:#f2e7d9}
  .parchment .tag{font-size:12px; color:#bda48f}

  /* Checklist */
  .todo{display:flex; align-items:flex-start; gap:10px; padding:10px 12px; border:1px solid #242428; border-radius:12px; margin-top:8px; background:#101014; justify-content:flex-start}
  .todo input[type="checkbox"]{transform:scale(1.2); margin-top:3px}
  .todo.done{opacity:.7}
  .kicker{font-family:Cinzel,serif; font-weight:700; letter-spacing:.4px}

  /* Vote list */
  .vote-list{display:grid; gap:8px}
  .vote-item{display:flex; align-items:center; gap:10px; padding:8px 10px; border:1px solid #242428; border-radius:10px; background:#0f0f13}
  .tally{font-variant-numeric:tabular-nums}

  /* Modal */
  dialog{border:none; border-radius:16px; padding:0; max-width:640px; width:calc(100% - 24px); background:#151519; color:#f0eef3; box-shadow:0 30px 80px rgba(0,0,0,.6)}
  .modal-head{padding:16px 18px; background:#1a0f13; border-bottom:1px solid #2b0e15; font-family:Cinzel,serif}
  .modal-body{padding:16px 18px}
  .modal-actions{padding:12px 18px; display:flex; justify-content:flex-end; gap:10px; border-top:1px solid #232327}
</style>
</head>
<body>
<header>
  <div class="title">Moonlit Bandanas</div>
  <div class="subtitle">Assignments • Clues • Mob Justice</div>
</header>

<div class="wrap">
  <nav class="tabs" role="tablist" aria-label="Moonlit App" id="topTabs">
    <button class="tab" id="tab-host" role="tab" aria-selected="true">Host Setup</button>
    <button class="tab" id="tab-join" role="tab" aria-selected="false">Join</button>
    <button class="tab" id="tab-clues" role="tab" aria-selected="false">Clues</button>
    <button class="tab" id="tab-admin" role="tab" aria-selected="false">Admin</button>
  </nav>

  <!-- HOST SETUP -->
  <section id="panel-host" class="panel" role="tabpanel" aria-labelledby="tab-host">
    <div class="grid grid-2">
      <div>
        <label>Room Code</label>
        <input id="roomCode" placeholder="e.g., REVEL-2025" />
        <div class="muted">Letters/numbers/dashes (3–30 chars).</div>

        <label style="margin-top:12px">Room Password</label>
        <input id="roomPassword" type="password" placeholder="Password players must enter" />
        <div class="muted">Stored as SHA-256 hash.</div>

        <label style="margin-top:12px">Admin Password (secret)</label>
        <input id="roomAdminPassword" type="password" placeholder="Required to unlock Admin" />
        <div class="muted">Stored as SHA-256 hash.</div>

        <div class="divider"></div>

        <label>Character Pool (name — biography, one per line)</label>
        <textarea id="rolePool"></textarea>

        <div class="divider"></div>

        <div class="row">
          <button class="btn" id="createRoomBtn">Create / Reset Room</button>
          <button class="btn secondary" id="fillDefaultsBtn">Reset To Default Characters</button>
        </div>
        <div id="hostStatus" style="margin-top:10px"></div>
      </div>

      <div class="card">
        <b>How it works</b>
        <ul>
          <li>Host creates a room with passwords.</li>
          <li>Players join and receive a random unclaimed character.</li>
          <li>Admin starts the game when ready. Before that, players only see their character (and role, if any).</li>
          <li>Admin controls rounds, clues, voting, deaths, and checks win conditions.</li>
        </ul>
      </div>
    </div>
  </section>

  <!-- JOIN -->
  <section id="panel-join" class="panel" role="tabpanel" aria-labelledby="tab-join" hidden>
    <div class="grid">
      <div>
        <label>Room Code</label>
        <input id="joinRoom" placeholder="Enter room code exactly" />
      </div>
      <div>
        <label>Room Password</label>
        <input id="joinPass" type="password" placeholder="Enter the room password" />
      </div>
      <div>
        <label>Your Real Name</label>
        <input id="realName" placeholder="e.g., Alex Johnson" />
      </div>
      <div class="row">
        <button class="btn" id="assignBtn">Get My Character</button>
        <button class="btn secondary" id="revealMineBtn">Reveal Mine Again</button>
      </div>
      <div id="assignStatus"></div>

      <div id="myRoleCard" class="card" style="display:none; margin-top:12px">
        <div class="row"><span class="badge success">Assigned</span></div>
        <h3 id="roleName" style="margin:8px 0 6px; font-family:Cinzel,serif"></h3>
        <div class="muted">When the host starts, your objectives will unlock.</div>
        <div class="row" style="margin-top:10px">
          <button class="btn secondary" id="copyRoleBtn">Copy to Clipboard</button>
        </div>
      </div>
    </div>
  </section>

  <!-- ACTIVE (no tab; hidden by default) -->
  <section id="panel-active" class="panel" hidden>
    <div class="grid">
      <div class="row" style="justify-content:space-between">
        <div class="row" style="gap:12px">
          <span class="pill" id="activeRoomPill">Room: —</span>
          <span class="pill" id="activeNamePill">Player: —</span>
          <!-- (Character pill removed by request) -->
          <span class="pill" id="roundPill">Round: —</span>
          <span class="pill" id="voteStatusPill">Vote: —</span>
          <span class="pill" id="voteCountdownPill">⏳ —</span>
        </div>
        <button class="btn secondary" id="refreshActiveBtn">Refresh</button>
      </div>

      <div class="divider"></div>

      <!-- Character summary + Role details -->
      <div class="card" id="charSummaryBox">
        <h3 class="kicker">Your Character</h3>
        <div id="charSummaryText" class="muted">—</div>
        <div id="roleDetailsBox" style="margin-top:10px"></div>
      </div>

      <!-- WAITING STATE -->
      <div id="waitingState" class="card">
        <h3 class="kicker">Waiting for Host to Start</h3>
        <div class="muted">You’ll see objectives, notes, and Mob Justice once the game begins.</div>
      </div>

      <div id="liveGameBlock" hidden>
        <div class="grid grid-2">
          <div>
            <h3 class="kicker">Your Objectives</h3>
            <div id="todoList" class="muted">—</div>
          </div>
          <div>
            <h3 class="kicker">Notes (private)</h3>
            <textarea id="notesBox" placeholder="Jot suspects, alibis, or reminders… (saved on this device)"></textarea>
            <div class="row" style="margin-top:8px">
              <button class="btn secondary" id="saveNotesBtn">Save Notes</button>
              <span class="muted">Notes are not uploaded.</span>
            </div>
          </div>
        </div>

        <div class="divider"></div>

        <!-- MOB JUSTICE (player) -->
        <div class="card">
          <h3 class="kicker">Mob Justice</h3>
          <div id="voteBlock">
            <div class="muted" id="voteHelp">Waiting for Admin to open voting…</div>
            <div id="candidateList" class="vote-list" style="margin-top:8px"></div>
            <div class="row" style="margin-top:10px">
              <button class="btn" id="castVoteBtn">Cast / Update Vote</button>
              <span class="muted">One vote per round; you can change it until voting closes.</span>
            </div>
            <div class="divider"></div>
            <div id="tallyBox" class="muted"></div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- CLUES -->
  <section id="panel-clues" class="panel" role="tabpanel" aria-labelledby="tab-clues" hidden>
    <div class="grid">
      <div class="row" style="gap:12px">
        <span class="pill">Revealed Clues</span>
        <button class="btn secondary" id="refreshCluesBtn">Refresh</button>
      </div>
      <div id="clueList" class="grid" style="gap:14px; margin-top:8px">
        <div class="muted">No clues revealed yet.</div>
      </div>
    </div>
  </section>

  <!-- ADMIN -->
  <section id="panel-admin" class="panel" role="tabpanel" aria-labelledby="tab-admin" hidden>
    <div class="grid">
      <!-- Admin gate -->
      <div class="card">
        <b>Admin Access</b>
        <div class="row" style="gap:12px; margin-top:8px">
          <div style="flex:1">
            <label>Room Code</label>
            <input id="adminRoom" placeholder="Room code" />
          </div>
          <div style="flex:1">
            <label>Admin Password</label>
            <input id="adminPass" type="password" placeholder="Admin password" />
          </div>
          <button class="btn" id="adminAuthBtn">Unlock Admin</button>
          <div id="adminAuthStatus"></div>
        </div>
      </div>

      <!-- Hidden until admin unlocks -->
      <div id="adminBody" hidden>
        <div class="grid grid-2">
          <div class="card">
            <h3>Characters</h3>
            <div class="row" style="gap:12px; flex-wrap:wrap">
              <button class="btn secondary" id="loadRoomBtn">Load Lists</button>
              <button class="btn secondary" id="watchRoomBtn">Live Watch</button>
              <select id="deadToggleSelect"><option value="">— select claimed player —</option></select>
              <button class="btn" id="markDeadBtn">Mark Dead</button>
              <button class="btn secondary" id="markAliveBtn">Mark Alive</button>
            </div>
            <div class="divider"></div>
            <h4>Unclaimed</h4>
            <div id="unclaimedBox" class="muted">—</div>
            <div class="divider"></div>
            <h4>Claimed</h4>
            <div id="claimedBox" class="muted">—</div>
          </div>

          <div class="card">
            <h3>Assign Special Roles</h3>
            <div class="muted">Select a claimed player and assign.</div>
            <div class="row" style="gap:12px; margin-top:8px">
              <select id="playerSelect"><option value="">— select player —</option></select>
              <select id="specialSelect">
                <option value="">(none)</option>
                <option>Elder Vampire</option>
                <option>Lesser Vampire</option>
                <option>Thrall</option>
                <option>Night Warden</option>
                <option>Mirrorcloak</option>
                <option>Gravespeaker</option>
              </select>
              <button class="btn" id="assignSpecialBtn">Assign</button>
            </div>
            <div id="specialStatus" style="margin-top:8px"></div>
          </div>
        </div>

        <!-- ROUND, GAME & VOTING CONTROLS -->
        <div class="card">
          <h3>Game, Round & Mob Justice Controls</h3>
          <div class="row" style="gap:10px; align-items:flex-end; flex-wrap:wrap">
            <div>
              <label>Game State</label>
              <input id="gameStateDisplay" disabled />
            </div>
            <button class="btn" id="startGameBtn">Start Game</button>
            <button class="btn secondary" id="stopGameBtn">Back to Waiting</button>
          </div>

          <div class="divider"></div>

          <div class="row" style="gap:10px; align-items:flex-end">
            <div>
              <label>Round</label>
              <input id="adminRoundDisplay" disabled />
            </div>
            <button class="btn" id="nextRoundBtn">Advance to Next Round</button>
          </div>

          <div class="divider"></div>

          <div class="row" style="gap:10px; align-items:flex-end; flex-wrap:wrap">
            <div>
              <label>Voting Status</label>
              <input id="votingStatusDisplay" disabled />
            </div>
            <button class="btn secondary" id="start5minVoteBtn">Start 5-Minute Vote</button>
            <button class="btn secondary" id="openVotingBtn">Open Voting</button>
            <button class="btn secondary" id="closeVotingBtn">Close Voting</button>
            <button class="btn secondary" id="clearVotingBtn">Clear Candidates & Votes</button>
          </div>

          <div class="divider"></div>

          <div class="row" style="gap:10px; align-items:flex-end; flex-wrap:wrap">
            <select id="candidatePlayerSelect"><option value="">— add candidate (claimed players) —</option></select>
            <button class="btn" id="addCandidateBtn">Add Candidate</button>
            <select id="removeCandidateSelect"><option value="">— remove candidate —</option></select>
            <button class="btn secondary" id="removeCandidateBtn">Remove</button>
          </div>

          <div class="divider"></div>

          <div id="adminTallyBox" class="muted">No votes yet.</div>
        </div>

        <!-- CSV IMPORT -->
        <div class="card">
          <h3>Import via CSV</h3>
          <div class="row" style="gap:14px; align-items:flex-end; flex-wrap:wrap">
            <div>
              <label>Characters CSV (name,description)</label>
              <input id="csvChars" type="file" accept=".csv" />
            </div>
            <button class="btn" id="importCharsBtn">Import Characters</button>
            <button class="btn secondary" id="useDefaultCharsBtn">Use Default Characters</button>
          </div>
          <div class="divider"></div>
          <div class="row" style="gap:14px; align-items:flex-end; flex-wrap:wrap">
            <div>
              <label>Clues CSV (id,title,body)</label>
              <input id="csvClues" type="file" accept=".csv" />
            </div>
            <button class="btn" id="importCluesBtn">Import Clues</button>
            <button class="btn secondary" id="useDefaultCluesBtn">Use Default Clues</button>
          </div>
          <div class="muted" id="csvStatus" style="margin-top:8px"></div>
        </div>
      </div>
    </div>
  </section>
</div>

<!-- Result modal -->
<dialog id="resultModal">
  <div class="modal-head" id="modalTitle">Result</div>
  <div class="modal-body" id="modalBody"></div>
  <div class="modal-actions">
    <button class="btn secondary" id="closeModalBtn">Close</button>
  </div>
</dialog>

<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-database-compat.js"></script>

<script>
/* =========================
   Debug & Config
========================= */
// When true, cookies are NOT written/read (easier multi-tab testing).
const DEBUG_NO_COOKIES = true;

/* =========================
   Tabs
========================= */
const TABS = [
  {btn:'tab-host',   panel:'panel-host'},
  {btn:'tab-join',   panel:'panel-join'},
  {btn:'tab-clues',  panel:'panel-clues'},
  {btn:'tab-admin',  panel:'panel-admin'},
];
TABS.forEach(({btn,panel})=>{
  document.getElementById(btn).addEventListener('click', ()=>{
    TABS.forEach(x=>{
      document.getElementById(x.btn).setAttribute('aria-selected', x.btn===btn ? 'true':'false');
      document.getElementById(x.panel).hidden = x.panel!==panel;
    });
    // Only unhide tabs if either admin is unlocked OR player has no character (so Active mode stays tab-less).
    const isAdminUnlocked = localStorage.getItem('mb_is_admin') === '1';
    const hasChar = !!localStorage.getItem('mb_charId');
    if (isAdminUnlocked || !hasChar) {
      document.getElementById('topTabs').classList.remove('hidden');
    }
    // Never auto-show Active panel on tab click
    document.getElementById('panel-active').hidden = true;
  });
});

/* =========================
   Characters (longer bios)
========================= */
const DEFAULT_CHAR_OBJS = [
  {name:"V. M. Pyre", desc:"A traveling fire performer who picks up odd jobs setting safe flame effects for events. Pyre regularly tests candle prototypes for Ember Hollow and keeps Raven Cask supplied with clean-burning wicks for tasting nights. Pyre and Thorn Ever once settled a messy tab together, which earned them a quiet reputation for being reliable when money is tight."},
  {name:"Ashen Vale", desc:"A level-headed apothecary who stocks practical remedies and tracks who needs a check-in. Ashen reminds Mist Graves to keep a night cord handy and swaps herb bundles with Ivy Haze during early market hours. When supplies run short, Ashen coordinates with Crypt Alder to restock without drama."},
  {name:"Gloom Ivy", desc:"A lantern carver who favors sturdy casings and bright, even light. Ivy buys glass panes from Cinder Wight and experiments with Sable Nyx to see how fragrance travels in different lighting. Ivy and Rune Lantern exchange simple fixes for wicks and hinges to keep shops safe."},
  {name:"Hex Rowan", desc:"A confident host for cards and dice who keeps rules clear and posted. Hex sets up at Ebon Thatch’s inn and asks Patch Wylde to shuffle and cut so players trust the deck. On busy nights, Hex asks Slate Crowe to jot down payouts to avoid misunderstandings."},
  {name:"Noct Rune", desc:"A quiet note taker who walks late routes with Lumen Wolfe and writes short, factual summaries each dawn. Noct files incident notes with Slate Crowe and keeps an eye on alley lamps from Rune Lantern’s workshop. When Dusk Mariner drops off sealed envelopes, Noct logs the handoff without opening them."},
  {name:"Cinder Wight", desc:"A patient glassblower who prefers stable heat, clear glass, and clean lines. Cinder supplies Ivy with panes that fit snugly and sells Ember Hollow jars sturdy enough for transport. During tastings at Ebon Thatch, Cinder sticks to water and leaves early to prep the morning kiln."},
  {name:"Marrow Quinn", desc:"A careful sketcher who is known for clean diagrams, labels, and practical notes. Marrow checks in with Ashen Vale about anatomy references for small injuries and works with Crypt Alder to keep labeled storage in order. When others argue, Marrow listens and sketches layouts to help people agree on next steps."},
  {name:"Ebon Thatch", desc:"A steady innkeeper who keeps seating fair and accounts simple. Ebon sets Hex Rowan’s games away from the bottleneck, puts Patch Wylde near the door, and tries Raven Cask’s new brews on quiet nights. When tensions rise, Ebon moves people around before problems start."},
  {name:"Sable Nyx", desc:"A perfumer who focuses on pleasant, practical blends for crowded rooms. Sable tests how scent travels in Gloom Ivy’s lantern light and buys unusual ingredients from Dusk Mariner when the ferry comes in. Sable keeps small samples for Ember Hollow to trial with long-burn candles."},
  {name:"Thorn Ever", desc:"A straightforward bookkeeper who balances tabs, posts totals, and closes accounts calmly. Thorn respects Slate Crowe’s record system and once helped V. M. Pyre straighten out an old debt with fair terms. When people disagree about who owes what, Thorn lays out the numbers without judgment."},
  {name:"Cob Webber", desc:"A practical maker of latches, traps, and hooks for storerooms and shops. Cob fits cellar locks for Ebon Thatch and builds sturdy hardware for Rune Lantern’s workbench. Night Jar often buys packaging hooks from Cob for fragile curios that don’t travel well."},
  {name:"Hallow Reed", desc:"A folk singer with a clear voice and steady tempo. Hallow performs with Piper Shade on quieter evenings and occasionally asks Echo Vane for factual checks before turning rumors into lyrics. Hallow keeps sets short when the room is tense and gives space to conversations when needed."},
  {name:"Mist Graves", desc:"A kind, reserved sleepwalker who keeps a night cord on the wrist to stay safe. Mist checks in with Ashen Vale about sleep habits and appreciates Noct Rune’s practical notes about safer routes home. Mist stores extra rope from Dusk Mariner for foggy nights."},
  {name:"Piper Shade", desc:"A flute seller and reliable accompanist who keeps time without stealing the spotlight. Piper plays with Hallow Reed on request and buys durable lamps from Rune Lantern for late packing. Piper and Ebon Thatch coordinate start times so music never interrupts announcements."},
  {name:"Rune Lantern", desc:"A lantern repairer and tinkerer who keeps affordable lamps on hand for homes and shops. Rune tests wicks for Ember Hollow and shows Gloom Ivy how to avoid heat warping on tighter casings. When Mist Graves asked for a dim nightlight, Rune built a simple, dependable model."},
  {name:"Bramble Kite", desc:"A messenger who moves notes around town quickly and keeps routes flexible during weather changes. Bramble uses Slate Crowe’s simple code marks for deliveries and relies on Dusk Mariner when fog shortens routes. When a message risks being misunderstood, Bramble asks for clarity before running it."},
  {name:"Frost Morn", desc:"An early-rising ice seller who organizes drop-offs before the sun warms cellars. Frost stores blocks at Ebon Thatch, supplies Ember Hollow during hot spells, and takes tea with Lumen Wolfe after the last run. When carts break down, Frost checks with Cob Webber for quick fixes."},
  {name:"Ember Hollow", desc:"A thorough candlemaker who labels wicks, scents, and burn times. Ember works with Cinder Wight for reliable jars and keeps a small list of ‘feedback tasters’ including Sable Nyx and V. M. Pyre. Echo Vane sometimes passes notes to test how rumors spread with different candle placements."},
  {name:"Wisp Harrow", desc:"A story collector who writes down what people say and separates hearsay from fact. Wisp listens to Hallow Reed’s sets for clean summaries and checks details with Echo Vane before noting them publicly. When Thorn Ever needs timeline clarity, Wisp provides dates and names without commentary."},
  {name:"Crypt Alder", desc:"A quartermaster who tracks incoming goods and what went missing. Crypt syncs with Slate Crowe’s records weekly and confirms with Raven Cask when shipments arrive. If someone complains, Crypt compares both lists, then asks Noct Rune whether any late-night issues were logged."},
  {name:"Omen Lark", desc:"A friendly street reader whose ‘predictions’ are usually tips about crowd flow and timing. Omen teases Hex Rowan about lucky streaks and suggests face-friendly mask shapes to Gourd Wilder. When Ebon Thatch expects a rush, Omen quietly nudges people toward spare seating."},
  {name:"Raven Cask", desc:"A brewer who experiments in small, labeled batches. Raven tests flavors with Ebon Thatch and keeps a tasting notebook V. M. Pyre references when open flames are part of a show. When supplies run low, Raven double-checks orders with Crypt Alder before changing a recipe."},
  {name:"Night Jar", desc:"A curio buyer and reseller who takes small risks on odd finds. Night Jar trades marked decks with Patch Wylde and orders secure hooks from Cob Webber for fragile items. When a piece carries a story, Night Jar asks Wisp Harrow to record it for the listing."},
  {name:"Lumen Wolfe", desc:"A volunteer night patrol who prefers straightforward routes and early starts. Lumen compares patrol notes with Noct Rune and buys long-burn candles from Ember Hollow for steady light. On cold mornings, Lumen meets Frost Morn for tea and route planning."},
  {name:"Patch Wylde", desc:"A card worker who keeps decks tidy, cuts cleanly, and favors posted rules. Patch partners with Hex Rowan on busier nights and prefers a chair near Ebon Thatch’s door to watch traffic. When disputes rise, Patch pauses the table and defers to Ebon’s seating judgment."},
  {name:"Echo Vane", desc:"A rumor collector who checks sources before repeating anything. Echo sometimes edits Hallow Reed’s lyrics to avoid naming names and shares neutral placement notes with Ember Hollow for crowd flow. Echo and Wisp Harrow trade dates and times to align their notes."},
  {name:"Dusk Mariner", desc:"A ferry operator on the bog path who runs ropes that hold in shifting fog. Dusk supplies spare lines to Mist Graves and passes sealed envelopes to Noct Rune for logging. When the weather turns, Dusk coordinates with Bramble Kite to keep deliveries moving."},
  {name:"Ivy Haze", desc:"An herb gatherer who brings labeled bundles to Ashen Vale and leaf samples to Gloom Ivy for testing under heat. Ivy shares tea with Wisp Harrow on slow afternoons and keeps small sachets for Raven Cask to trial in new brews."},
  {name:"Slate Crowe", desc:"A record keeper who logs meetings, deliveries, and decisions with simple cross-references. Slate checks Thorn Ever’s tallies monthly and gives Bramble Kite signaling marks for routine messages. When confusion arises, Slate pulls the right page and points to the line."},
  {name:"Gourd Wilder", desc:"A mask artisan focused on comfortable fit and clear sight lines. Gourd takes orders from Night Jar, builds shop guards for Cob Webber, and asks Omen Lark about crowd patterns before carving showy pieces. When performers complain, Gourd adjusts straps and pads without fuss."}
];

const DEFAULT_TASKS = [
  "Learn two names and one hobby.",
  "Trade a small trinket or token with someone.",
  "Share one rumor or clue you’ve heard.",
  "Publicly vouch for or accuse exactly one person.",
  "Find someone who matches a clue and ask them about it."
];

const DEFAULT_CLUES = [
  {id:"E1", title:"The Dimming of Candles", body:"In the glassblower’s stall, a trio of candles guttered all at once, as though a mouth had drawn in the room’s breath. Witnesses swore the figure who passed by wore a ring that drank the light. They left no soot, only a whisper of clove."},
  {id:"E2", title:"The Whispering Step", body:"Near the square of empty masks, a watcher heard footfalls that seemed to land after their own echoes. The gait was even, decisive, and oddly weightless—as if the night itself cushioned each stride."},
  {id:"E3", title:"Threads by the Well", body:"By the old wishing well, a single thread of deep red snagged on weathered stone, the shade of a harvest moon. No cloak nearby bore that hue—perhaps it belonged to a sash tied close to the heart."},
  {id:"E4", title:"The Breath That Wasn’t", body:"Flutes lay in their case, and yet a mourning note hung in the air as if blown by no mouth at all. The player who lingered exhaled fog though the night was warm, and smiled without teeth."},
  {id:"E5", title:"The Lantern That Blinked", body:"A tinker’s lantern fluttered near a laughing circle—then steadied when a single figure drew near and asked no questions. Lies make it flicker, the tinker swears."},
  {id:"E6", title:"A Toast to Nowhere", body:"Someone raised an empty cup and murmured a phrase not quite language, not quite song. Those within earshot forgot a name they had just learned. The smell of old cellars followed."},
  {id:"E7", title:"Left Hand of Dusk", body:"Chalk tallies were scrawled backward on a ledger margin, lines neat yet mirrored. Whoever wrote them favored the left hand and the calm of twilight."},
  {id:"E8", title:"The Silver Coin Gone Cold", body:"A coin traded thrice in an hour turned cold enough to mist a mirror. The last to hold it tucked it away with clinical care, as though cataloging a specimen."},
  {id:"L1", title:"The Heir in the Crowd", body:"When the bells tolled, a shadow took shelter in another’s laughter. The heir does not stand alone; they orbit a brighter star to dim their edges."},
  {id:"L2", title:"The Smile That Stops", body:"A chuckle rang out, crisp as cracked ice, but ended sharply—habit, not humor. Hands drifted to pockets where keys or coins clicked in nervous code."},
  {id:"L3", title:"Scent of Wet Stone", body:"On the path to the bog ferries, a scent of wet stone trailed someone who avoids shallow water, preferring docks’ deeper quiet."},
  {id:"L4", title:"The Double Shadow", body:"Two silhouettes overlapped beneath a single lantern: one tall and still, the other shifting, impatient. Only one turned when hailed."},
  {id:"L5", title:"The Hat with No Owner", body:"A brim with a feather of ash-gray was left on a chair that always faces the door. No one claimed it—but more than one person looked too long at its seat."},
  {id:"L6", title:"Ink Under the Nail", body:"A knuckle brushed paper and left a crescent of black under the nail—old ink that no wash could fully banish."},
  {id:"D1", title:"Red Herring: The Laughing Mask", body:"A maskmaker insisted a mask smiled on its own when a brewer sang off-key. Sweet nonsense, perhaps, or theater."},
  {id:"D2", title:"Red Herring: The Garlic Fable", body:"Someone swore they saw a cloaked patron recoil from garlic… but the cloves were candied. Theatrical groaning followed."}
];

/* =========================
   Firebase (paste config)
========================= */
const firebaseConfig = {
  apiKey: "AIzaSyDNqVMgr5CHIe-ajgikCaJp0kzB2CpbOWs",
  authDomain: "murdermystery-cd241.firebaseapp.com",
  databaseURL: "https://murdermystery-cd241-default-rtdb.firebaseio.com",
  projectId: "murdermystery-cd241",
  storageBucket: "murdermystery-cd241.firebasestorage.app",
  messagingSenderId: "724748560349",
  appId: "1:724748560349:web:4ba1d4f5ed874419167834",
  measurementId: "G-7RS065D3HZ"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.database();

/* =========================
   Helpers & modal
========================= */
const byId = id => document.getElementById(id);
const setPill = (id,t)=> byId(id).textContent = t;
const hashSHA256 = async (text)=>{
  const enc = new TextEncoder().encode(text);
  const buf = await crypto.subtle.digest('SHA-256', enc);
  return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join('');
};
function setCookie(name,value,days){
  if (DEBUG_NO_COOKIES) return;
  const d = new Date(); d.setTime(d.getTime() + (days*24*60*60*1000));
  document.cookie = `${name}=${encodeURIComponent(value)}; expires=${d.toUTCString()}; path=/; SameSite=Lax`;
}
function getCookie(name){
  if (DEBUG_NO_COOKIES) return '';
  const m = document.cookie.match(new RegExp('(^| )'+name+'=([^;]+)')); return m ? decodeURIComponent(m[2]) : '';
}
const modal = byId('resultModal');
byId('closeModalBtn').addEventListener('click', ()=> modal.close());
function popup(title, html){
  byId('modalTitle').textContent = title;
  byId('modalBody').innerHTML = html;
  modal.showModal();
}

/* Always show Admin tab button; panel remains locked until password */
function showAdminTab(){ byId('tab-admin').style.display = ''; }
showAdminTab();

/* =========================
   Host Setup
========================= */
const rolePoolEl = byId('rolePool');
byId('fillDefaultsBtn').addEventListener('click', ()=>{
  rolePoolEl.value = DEFAULT_CHAR_OBJS.map(o=>`${o.name} — ${o.desc}`).join("\n");
});
byId('fillDefaultsBtn').click();

byId('createRoomBtn').addEventListener('click', async ()=>{
  const codeRaw = (byId('roomCode').value||'').trim();
  const passRaw = (byId('roomPassword').value||'').trim();
  const adminPassRaw = (byId('roomAdminPassword').value||'').trim();
  const hostStatus = byId('hostStatus');
  if (!/^[A-Za-z0-9-]{3,30}$/.test(codeRaw)){ hostStatus.innerHTML = `<span class="badge danger">Invalid room code</span>`; return; }
  if (!passRaw || passRaw.length < 4){ hostStatus.innerHTML = `<span class="badge danger">Room password too short</span>`; return; }
  if (!adminPassRaw || adminPassRaw.length < 6){ hostStatus.innerHTML = `<span class="badge danger">Admin password too short</span>`; return; }
  const code = codeRaw.toUpperCase();
  const passHash = await hashSHA256(passRaw);
  const adminHash = await hashSHA256(adminPassRaw);
  const lines = (rolePoolEl.value||'').split('\n').map(s=>s.trim()).filter(Boolean);
  const unique = [...new Set(lines)];
  if (!unique.length){ hostStatus.innerHTML = `<span class="badge danger">No characters provided</span>`; return; }
  const chars = {};
  unique.forEach((line, i)=>{
    const id = 'c_'+i.toString().padStart(3,'0');
    const [name, ...rest] = line.split('—');
    const nm = (name||'').trim();
    const desc = (rest.join('—')||'').trim() || null;
    chars[id] = {name: nm + (desc? ` — ${desc}`:''), desc, claimedBy:null, claimedAt:null, dead:false};
  });
  const clues = {}; DEFAULT_CLUES.forEach(c=>{ clues[c.id] = {title:c.title, body:c.body, revealed:false}; });
  const state = { gameStarted:false, round: 1, voting: { open:false, closed:false, candidates:null, votes:null, endsAt:null } };
  try{
    await db.ref(`rooms/${code}`).set({
      passHash, adminHash, createdAt: Date.now(),
      characters: chars, users: null, clues, state
    });
    hostStatus.innerHTML = `<span class="badge success">Room ready</span> <b class="mono">${code}</b>`;
    localStorage.setItem('mb_room_host', code);
  }catch(e){
    hostStatus.innerHTML = `<span class="badge danger">Error</span> ${e.message}`;
  }
});

/* =========================
   Join & Claim
========================= */
function saveLocal(room,name,charId,charName){
  localStorage.setItem('mb_room', room);
  localStorage.setItem('mb_name', name);
  localStorage.setItem('mb_charId', charId);
  localStorage.setItem('mb_charName', charName);
}
function getUid(room,name){ return btoa(`${name}::${room}`).replace(/=+$/,''); }
async function verifyRoomPassword(room, pass){
  const snap = await db.ref(`rooms/${room}/passHash`).get();
  if (!snap.exists()) throw new Error('Room not found');
  return (await hashSHA256(pass)) === snap.val();
}

async function claimCharacter(room, pass, realName){
  const r = room.toUpperCase();
  const ok = await verifyRoomPassword(r, pass);
  if (!ok) throw new Error('Incorrect password');
  const rolesSnap = await db.ref(`rooms/${r}/characters`).get();
  if (!rolesSnap.exists()) throw new Error('No characters in this room');
  const entries = Object.entries(rolesSnap.val());
  const unclaimed = entries.filter(([id,c])=>!c.claimedBy).map(([id,c])=>({id,name:c.name}));
  if (!unclaimed.length) throw new Error('All characters are taken');
  const pick = unclaimed[Math.floor(Math.random()*unclaimed.length)];
  const ref = db.ref(`rooms/${r}/characters/${pick.id}`);
  const res = await new Promise((resolve, reject)=>{
    ref.transaction(curr=>{
      if (!curr) return curr;
      if (curr.claimedBy) return;
      return {...curr, claimedBy: realName, claimedAt: Date.now()};
    }, (error, committed, snapshot)=>{
      if (error) return reject(error);
      resolve({committed, snapshot});
    }, false);
  });
  if (!res.committed) return claimCharacter(r, pass, realName);

  const uid = getUid(r, realName);
  await new Promise((resolve, reject)=>{
    db.ref(`rooms/${r}/users/${uid}`).transaction(curr=>{
      if (curr) return curr;
      return {
        name: realName,
        charId: pick.id,
        specialRole: null,
        tasks: DEFAULT_TASKS.map(t=>({text:t, done:false})),
        dead:false
      };
    }, (error, committed)=>{
      if (error) return reject(error);
      resolve(committed);
    }, false);
  });
  saveLocal(r, realName, pick.id, pick.name);
  setCookie('mb_room', r, 30);
  setCookie('mb_name', realName, 30);
  return pick.name;
}

byId('assignBtn').addEventListener('click', async ()=>{
  const room = (byId('joinRoom').value||'').trim();
  const pass = (byId('joinPass').value||'').trim();
  const name = (byId('realName').value||'').trim();
  const status = byId('assignStatus');
  if (!room || !pass || !name){ status.innerHTML = `<span class="badge danger">Enter room, password, and name</span>`; return; }
  status.textContent = 'Assigning…';
  try{
    const charName = await claimCharacter(room, pass, name);
    status.innerHTML = `<span class="badge success">Assigned</span>`;
    byId('roleName').textContent = `${charName} — assigned to ${name}`;
    byId('myRoleCard').style.display = '';
    collapseToActiveOnly();
    refreshActive();
  }catch(e){
    status.innerHTML = `<span class="badge danger">Error</span> ${e.message}`;
  }
});

byId('revealMineBtn').addEventListener('click', async ()=>{
  const room = (byId('joinRoom').value||'').trim().toUpperCase();
  const pass = (byId('joinPass').value||'').trim();
  const name = (byId('realName').value||'').trim();
  const status = byId('assignStatus');
  if (!room || !pass || !name){ status.innerHTML=`<span class="badge danger">Enter room, password, and name</span>`; return; }
  try{
    const ok = await verifyRoomPassword(room, pass);
    if (!ok) throw new Error('Incorrect password');
    const uid = getUid(room, name);
    const uSnap = await db.ref(`rooms/${room}/users/${uid}`).get();
    if (!uSnap.exists()){ status.innerHTML=`<span class="badge danger">No prior assignment</span>`; return; }
    const {charId} = uSnap.val();
    const rSnap = await db.ref(`rooms/${room}/characters/${charId}`).get();
    const charName = rSnap.exists() ? rSnap.val().name : '(unknown)';
    saveLocal(room, name, charId, charName);
    setCookie('mb_room', room, 30);
    setCookie('mb_name', name, 30);
    byId('roleName').textContent = `${charName} — assigned to ${name}`;
    byId('myRoleCard').style.display = '';
    status.innerHTML = `<span class="badge success">Found</span>`;
    collapseToActiveOnly();
    refreshActive();
  }catch(e){
    status.innerHTML = `<span class="badge danger">Error</span> ${e.message}`;
  }
});

byId('copyRoleBtn').addEventListener('click', async ()=>{
  const txt = byId('roleName').textContent;
  try{ await navigator.clipboard.writeText(txt); }catch{}
  alert('Copied:\n'+txt);
});

/* =========================
   Active Mode
========================= */
function loadLocalIdentity(){
  return {
    room: localStorage.getItem('mb_room') || '',
    name: localStorage.getItem('mb_name') || '',
    charId: localStorage.getItem('mb_charId') || '',
    charName: localStorage.getItem('mb_charName') || '',
  };
}
async function getRoomState(room){
  const snap = await db.ref(`rooms/${room}/state`).get();
  if (!snap.exists()) return { gameStarted:false, round:1, voting:{open:false,closed:false,candidates:null,votes:null,endsAt:null} };
  return snap.val();
}

async function refreshActive(){
  const {room,name,charId,charName} = loadLocalIdentity();

  // If player has no character, keep Active hidden and show normal tabs
  const hasChar = !!charId;
  const isAdminUnlocked = localStorage.getItem('mb_is_admin') === '1';
  if (!hasChar){
    byId('panel-active').hidden = true;
    byId('topTabs').classList.remove('hidden');
    return;
  }

  // Player has a character: show Active panel and hide tabs if not admin
  if (!isAdminUnlocked) byId('topTabs').classList.add('hidden');

  setPill('activeRoomPill', `Room: ${room||'—'}`);
  setPill('activeNamePill', `Player: ${name||'—'}`);

  const uid = getUid(room, name);
  const [userSnap, stateSnap, charsSnap, usersSnap] = await Promise.all([
    db.ref(`rooms/${room}/users/${uid}`).get(),
    db.ref(`rooms/${room}/state`).get(),
    db.ref(`rooms/${room}/characters`).get(),
    db.ref(`rooms/${room}/users`).get()
  ]);
  const state = stateSnap.exists()? stateSnap.val(): {gameStarted:false, round:1, voting:{}};
  const voting = state.voting || {};
  const chars = charsSnap.exists()? charsSnap.val(): {};
  const users = usersSnap.exists()? usersSnap.val(): {};

  setPill('roundPill', `Round: ${state.round||1}`);
  setPill('voteStatusPill', `Vote: ${voting.open ? 'OPEN' : (voting.closed ? 'CLOSED' : '—')}`);
  updateCountdownPill(voting.endsAt);

  if (!userSnap.exists()){
    byId('charSummaryText').innerHTML = '—';
    byId('roleDetailsBox').innerHTML = '';
    byId('waitingState').hidden = false;
    byId('liveGameBlock').hidden = true;
    byId('panel-active').hidden = false;
  }else{
    const me = userSnap.val();

    // Character summary (use combined string from characters.name)
    const charRec = me.charId && chars[me.charId] ? chars[me.charId] : null;
    const charLine = charRec ? charRec.name : (charName||'—');
    byId('charSummaryText').innerHTML = `<div><b>${charLine}</b></div>`;

    // Role details (inline; villain visibility)
    byId('roleDetailsBox').innerHTML = renderRoleDetails(me, users, chars);

    // Waiting vs live
    if (!state.gameStarted){
      byId('waitingState').hidden = false;
      byId('liveGameBlock').hidden = true;
    }else{
      byId('waitingState').hidden = true;
      byId('liveGameBlock').hidden = false;

      // Objectives: reveal one per round (cumulative)
      const toShow = Math.min(me.tasks?.length||0, state.round||1);
      const tasks = (me.tasks||[]).slice(0, toShow);
      const list = tasks.map((t,i)=>`
        <label class="todo ${t.done?'done':''}">
          <input type="checkbox" data-ix="${i}" ${t.done?'checked':''}/>
          <div>${t.text}</div>
        </label>`).join('');
      byId('todoList').innerHTML = list || '<div class="muted">No tasks found.</div>';
      [...byId('todoList').querySelectorAll('input[type="checkbox"]')].forEach(cb=>{
        cb.addEventListener('change', async (e)=>{
          const ix = Number(e.target.getAttribute('data-ix'));
          await db.ref(`rooms/${room}/users/${uid}/tasks/${ix}/done`).set(e.target.checked);
          refreshActive();
        });
      });

      await renderPlayerVoting(room, uid, state);
    }

    byId('panel-active').hidden = false;
  }
}
byId('refreshActiveBtn').addEventListener('click', refreshActive);

byId('saveNotesBtn').addEventListener('click', ()=>{
  const {room,name} = loadLocalIdentity();
  if (!room || !name){ alert('Join first.'); return; }
  const key = `mb_notes_${room}_${name}`;
  localStorage.setItem(key, byId('notesBox').value);
  alert('Notes saved.');
});

/* Countdown pill */
let countdownTimer=null;
function updateCountdownPill(endsAt){
  if (countdownTimer){ clearInterval(countdownTimer); countdownTimer=null; }
  const pill = byId('voteCountdownPill');
  if (!endsAt){ pill.textContent = '⏳ —'; return; }
  function tick(){
    const ms = Math.max(0, endsAt - Date.now());
    const m = Math.floor(ms/60000), s = Math.floor((ms%60000)/1000).toString().padStart(2,'0');
    pill.textContent = `⏳ ${m}:${s}`;
    if (ms<=0 && countdownTimer){ clearInterval(countdownTimer); countdownTimer=null; }
  }
  tick();
  countdownTimer = setInterval(tick, 1000);
}

/* Role details rendering & villain visibility */
function aliveStatus(u, chars){ const dead = u?.dead || (u?.charId && chars[u.charId]?.dead); return dead ? ' (dead)' : ' (alive)'; }
function roleDetailsText(role){
  switch(role){
    case 'Elder Vampire': return 'Primary killer. One target per round, and +1 additional kill each round (bandana snatch). Knows the Lesser Vampire and the Thrall.';
    case 'Lesser Vampire': return 'Succeeds the Elder upon Elder’s death. Knows the Elder and the Thrall. Has no thrall.';
    case 'Thrall': return 'Once-per-game compelled kill on Elder’s command; obeys Elder’s orders. Freed if the Elder dies.';
    case 'Night Warden': return 'Openly armed hunter (nerf blaster). May eliminate one target per round. May hit innocent or vampire.';
    case 'Mirrorcloak': return 'Hidden avenger. If attacked by the vampire or thrall, the attacker dies instantly.';
    case 'Gravespeaker': return 'Medium. After each death, may speak with the dead; each spirit can publicly clear one other player as innocent.';
    default: return null;
  }
}
function renderRoleDetails(me, users, chars){
  if (!me.specialRole) return '';
  const base = `<div class="card" style="margin-top:8px">
      <div><b>Role:</b> ${me.specialRole}</div>
      <div class="muted" style="margin-top:6px">${roleDetailsText(me.specialRole)||''}</div>`;
  if (me.specialRole === 'Elder Vampire' || me.specialRole === 'Lesser Vampire'){
    let elder=null, lesser=null, thrall=null;
    for (const [uid,u] of Object.entries(users||{})){
      if (u.specialRole === 'Elder Vampire') elder = {uid,u};
      if (u.specialRole === 'Lesser Vampire') lesser = {uid,u};
      if (u.specialRole === 'Thrall') thrall = {uid,u};
    }
    const lines=[];
    if (elder) lines.push(`Elder Vampire: <b>${elder.u.name}</b>${aliveStatus(elder.u, chars)}`);
    if (lesser) lines.push(`Lesser Vampire: <b>${lesser.u.name}</b>${aliveStatus(lesser.u, chars)}`);
    if (thrall) lines.push(`Thrall: <b>${thrall.u.name}</b>${aliveStatus(thrall.u, chars)}`);
    return base + (lines.length? `<div style="margin-top:10px">${lines.map(x=>`• ${x}`).join('<br>')}</div>`:'') + `</div>`;
  }
  if (me.specialRole === 'Thrall'){
    let elder=null;
    for (const [uid,u] of Object.entries(users||{})){
      if (u.specialRole === 'Elder Vampire') elder = {uid,u};
    }
    const freed = elder ? (elder.u.dead || (elder.u.charId && chars[elder.u.charId]?.dead)) : false;
    const line = elder ? `Elder Vampire: <b>${elder.u.name}</b>${aliveStatus(elder.u, chars)}${freed?' — you are <b>SET FREE</b>.':''}` : 'Elder Vampire: (unknown)';
    return base + `<div style="margin-top:10px">• ${line}</div></div>`;
  }
  return base + `</div>`;
}

/* Player voting UI */
async function renderPlayerVoting(room, uid, state){
  const help = byId('voteHelp'), list = byId('candidateList'), tallyBox = byId('tallyBox');
  const btn = byId('castVoteBtn');
  const voting = state.voting || {open:false,closed:false};
  updateCountdownPill(voting.endsAt);
  if (!voting.open && !voting.closed){
    help.textContent = 'Waiting for Admin to open voting…';
    list.innerHTML = ''; tallyBox.innerHTML = ''; btn.disabled = true; return;
  }
  const [usersSnap, charsSnap] = await Promise.all([
    db.ref(`rooms/${room}/users`).get(),
    db.ref(`rooms/${room}/characters`).get()
  ]);
  const users = usersSnap.exists() ? usersSnap.val() : {};
  const chars = charsSnap.exists() ? charsSnap.val() : {};
  const candidates = voting.candidates || {};
  const votes = voting.votes || {};
  const items = Object.keys(candidates);
  const display = items.map(k=>{
    const u = users[k]; const charName = u && u.charId && chars[u.charId] ? chars[u.charId].name : '';
    const dead = u?.dead || (u?.charId && chars[u.charId]?.dead);
    return {key:k, label: u ? `${u.name}${charName? ' — '+charName:''}${dead?' (dead)':''}` : k, dead: !!dead};
  });
  const myVote = votes[uid] || '';

  if (voting.open){
    help.textContent = 'Voting is OPEN. Choose one candidate:';
    list.innerHTML = display.map(d=>`
      <label class="vote-item">
        <input type="radio" name="voteChoice" value="${d.key}" ${myVote===d.key?'checked':''} ${d.dead?'disabled':''}/>
        <div>${d.label}</div>
      </label>
    `).join('') || '<div class="muted">No candidates yet.</div>';
    btn.disabled = false;
    tallyBox.innerHTML = '<span class="muted">Tally will appear when voting closes.</span>';
  }else{
    help.textContent = 'Voting is CLOSED. Final tally:';
    list.innerHTML = display.map(d=>`<div class="vote-item"><div>${d.label}</div></div>`).join('') || '<div class="muted">No candidates.</div>';
    btn.disabled = true;
    const tally = {};
    Object.entries(votes).forEach(([voter, choice])=>{
      const u = users[voter]; const aliveVoter = u && !u.dead && !(u.charId && chars[u.charId]?.dead);
      if (aliveVoter) tally[choice] = (tally[choice]||0)+1;
    });
    const tallyLines = display.map(d=>`• ${d.label}: <b class="tally">${tally[d.key]||0}</b>`).join('<br>');
    tallyBox.innerHTML = tallyLines || 'No votes.';
  }
}
byId('castVoteBtn').addEventListener('click', async ()=>{
  const {room,name} = loadLocalIdentity();
  if (!room || !name) return;
  const uid = getUid(room,name);
  const state = await getRoomState(room);
  if (!state.voting?.open){ alert('Voting is not open.'); return; }
  const choice = document.querySelector('input[name="voteChoice"]:checked');
  if (!choice){ alert('Pick a candidate.'); return; }
  await db.ref(`rooms/${room}/state/voting/votes/${uid}`).set(choice.value);
  alert('Vote recorded.');
  refreshActive();
});

/* Clues (player) */
async function renderClues(){
  const room = localStorage.getItem('mb_room') || (byId('joinRoom').value||'').trim().toUpperCase();
  const list = byId('clueList');
  if (!room){ list.innerHTML = '<div class="muted">Join a room first.</div>'; return; }
  const snap = await db.ref(`rooms/${room}/clues`).get();
  if (!snap.exists()){ list.innerHTML = '<div class="muted">No clues seeded.</div>'; return; }
  const clues = Object.entries(snap.val()).filter(([id,c])=>c.revealed);
  if (!clues.length){ list.innerHTML = '<div class="muted">No clues revealed yet.</div>'; return; }
  list.innerHTML = clues.map(([id,c])=>`
    <article class="parchment">
      <div class="tag">Clue ${id}</div>
      <h4>${c.title}</h4>
      <div>${c.body}</div>
    </article>
  `).join('');
}
byId('refreshCluesBtn').addEventListener('click', renderClues);
document.getElementById('tab-clues').addEventListener('click', renderClues);

/* =========================
   Admin
========================= */
let ADMIN_OK = false;
async function adminAuth(){
  const room = (byId('adminRoom').value||'').trim().toUpperCase();
  const adminPass = (byId('adminPass').value||'').trim();
  const out = byId('adminAuthStatus');
  try{
    const snap = await db.ref(`rooms/${room}/adminHash`).get();
    if (!snap.exists()) throw new Error('Room not found');
    const ok = (await hashSHA256(adminPass)) === snap.val();
    if (!ok) throw new Error('Incorrect admin password');
    ADMIN_OK = true;
    localStorage.setItem('mb_room_admin', room);
    localStorage.setItem('mb_is_admin', '1'); // mark this device as admin-unlocked
    out.innerHTML = `<span class="badge success">Admin unlocked</span>`;
    byId('adminBody').hidden = false; // show admin controls
    await refreshAdminAll();
  }catch(e){
    ADMIN_OK = false;
    byId('adminBody').hidden = true;
    out.innerHTML = `<span class="badge danger">Auth failed</span> ${e.message}`;
  }
}
byId('adminAuthBtn').addEventListener('click', adminAuth);
function currentAdminRoom(){ return (byId('adminRoom').value||localStorage.getItem('mb_room_admin')||'').toUpperCase(); }
async function refreshAdminAll(){
  await updateRoundGameVotingDisplays();
  await refreshPlayerDropdowns();
  await refreshCandidateSelectors();
  await renderAdminTally();
}

/* Lists render */
function renderLists(data){
  const chars = data||{};
  const entries = Object.entries(chars);
  const un = entries.filter(([id,c])=>!c.claimedBy).map(([id,c])=>`• ${c.name}${c.dead?' (dead)':''}`).join("<br>") || '—';
  const cl = entries.filter(([id,c])=>c.claimedBy).map(([id,c])=>`• <b>${c.name}</b> <span class="muted">→ ${c.claimedBy}${c.dead?' (dead)':''}</span>`).join("<br>") || '—';
  byId('unclaimedBox').innerHTML = un;
  byId('claimedBox').innerHTML = cl;
}

let liveOff = null;
byId('loadRoomBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK){ byId('adminAuthStatus').innerHTML=`<span class="badge danger">Unlock Admin first</span>`; return; }
  const room = currentAdminRoom();
  const snap = await db.ref(`rooms/${room}/characters`).get();
  if (!snap.exists()){ byId('adminAuthStatus').innerHTML=`<span class="badge danger">Room not found</span>`; return; }
  renderLists(snap.val());
  await refreshAdminAll();
});

byId('watchRoomBtn').addEventListener('click', ()=>{
  if (!ADMIN_OK){ byId('adminAuthStatus').innerHTML=`<span class="badge danger">Unlock Admin first</span>`; return; }
  const room = currentAdminRoom();
  if (liveOff) { liveOff(); liveOff=null; }
  const ref = db.ref(`rooms/${room}`);
  const cb = ref.on('value', async snap=> {
    const data = snap.val()||{};
    renderLists(data.characters||{});
    await refreshAdminAll();
  });
  liveOff = ()=> ref.off('value', cb);
  byId('adminAuthStatus').innerHTML = `<span class="badge">Watching live…</span>`;
});

async function refreshPlayerDropdowns(){
  const room = currentAdminRoom();
  const usersSnap = await db.ref(`rooms/${room}/users`).get();
  const sel = byId('playerSelect');
  const candSel = byId('candidatePlayerSelect');
  const deadSel = byId('deadToggleSelect');
  sel.innerHTML = '<option value="">— select player —</option>';
  candSel.innerHTML = '<option value="">— add candidate (claimed players) —</option>';
  deadSel.innerHTML = '<option value="">— select claimed player —</option>';
  if (!usersSnap.exists()) return;
  const users = usersSnap.val();
  for (const [uid,u] of Object.entries(users)){
    const opt = document.createElement('option'); opt.value = uid; opt.textContent = u.name;
    sel.appendChild(opt);
    const opt2 = document.createElement('option'); opt2.value = uid; opt2.textContent = u.name;
    candSel.appendChild(opt2);
    const opt3 = document.createElement('option'); opt3.value = uid; opt3.textContent = `${u.name}${u.dead?' (dead)':''}`;
    deadSel.appendChild(opt3);
  }
}
document.getElementById('tab-admin').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  await refreshAdminAll();
});

/* Assign roles */
byId('assignSpecialBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK){ byId('specialStatus').innerHTML=`<span class="badge danger">Unlock Admin</span>`; return; }
  const room = currentAdminRoom();
  const uid = byId('playerSelect').value;
  const role = byId('specialSelect').value || null;
  if (!uid){ byId('specialStatus').innerHTML=`<span class="badge danger">Pick a player</span>`; return; }
  await db.ref(`rooms/${room}/users/${uid}/specialRole`).set(role);
  byId('specialStatus').innerHTML = `<span class="badge success">Saved</span>`;
  await checkWinConditions(room);
});

/* Mark Dead/Alive */
byId('markDeadBtn').addEventListener('click', ()=> toggleDead(true));
byId('markAliveBtn').addEventListener('click', ()=> toggleDead(false));
async function toggleDead(dead){
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  const uid = byId('deadToggleSelect').value;
  if (!uid) return;
  const uSnap = await db.ref(`rooms/${room}/users/${uid}`).get();
  if (!uSnap.exists()) return;
  const u = uSnap.val();
  await db.ref(`rooms/${room}/users/${uid}/dead`).set(dead);
  if (u.charId) await db.ref(`rooms/${room}/characters/${u.charId}/dead`).set(dead);
  await renderAdminTally();
  await updateRoundGameVotingDisplays();
  await checkWinConditions(room, dead ? `Marked ${u.name} dead.` : `Marked ${u.name} alive.`);
}

/* Game / Round / Voting Controls */
async function getState(room){ return (await db.ref(`rooms/${room}/state`).get()).val()||{}; }

async function updateRoundGameVotingDisplays(){
  const room = currentAdminRoom();
  const state = await getState(room);
  byId('adminRoundDisplay').value = state.round || 1;
  byId('votingStatusDisplay').value = state.voting?.open ? 'OPEN' : (state.voting?.closed ? 'CLOSED' : '—');
  byId('gameStateDisplay').value = state.gameStarted ? 'STARTED' : 'WAITING';
}

byId('startGameBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  const state = await getState(room);
  await db.ref(`rooms/${room}/state`).set({
    gameStarted:true,
    round: state.round || 1,
    voting: { open:false, closed:false, candidates:null, votes:null, endsAt:null }
  });
  await updateRoundGameVotingDisplays();
  popup('Game Started', 'Players now see objectives, notes, and Mob Justice.');
});

byId('stopGameBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  const state = await getState(room);
  await db.ref(`rooms/${room}/state`).set({
    gameStarted:false,
    round: state.round || 1,
    voting: { open:false, closed:false, candidates:null, votes:null, endsAt:null }
  });
  await updateRoundGameVotingDisplays();
  popup('Back to Waiting', 'Players now see only character and role info.');
});

byId('nextRoundBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  const state = await getState(room);
  const next = (state.round||1) + 1;
  await db.ref(`rooms/${room}/state`).set({
    gameStarted: state.gameStarted || false,
    round: next,
    voting: { open:false, closed:false, candidates:null, votes:null, endsAt:null }
  });
  await updateRoundGameVotingDisplays();
  await renderAdminTally();
  await checkWinConditions(room, `Advanced to Round ${next}.`);
});

/* Voting Open/Close/Clear and Timer */
byId('openVotingBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  const state = await getState(room);
  await db.ref(`rooms/${room}/state/voting`).set({
    open:true, closed:false,
    candidates: state.voting?.candidates || null,
    votes: state.voting?.votes || null,
    endsAt:null
  });
  await updateRoundGameVotingDisplays(); await renderAdminTally();
});

byId('closeVotingBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  await closeVotingAndResolve(room, true);
});

byId('clearVotingBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  await db.ref(`rooms/${room}/state/voting`).set({ open:false, closed:false, candidates:null, votes:null, endsAt:null });
  await updateRoundGameVotingDisplays(); await refreshCandidateSelectors(); await renderAdminTally();
});

byId('start5minVoteBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  const endsAt = Date.now() + 5*60*1000;
  const state = await getState(room);
  await db.ref(`rooms/${room}/state/voting`).set({
    open:true, closed:false,
    candidates: state.voting?.candidates || null,
    votes: state.voting?.votes || null,
    endsAt
  });
  await updateRoundGameVotingDisplays(); await renderAdminTally();
  scheduleAutoClose(room, endsAt);
});

/* Candidate add/remove */
async function refreshCandidateSelectors(){
  const room = currentAdminRoom();
  const state = await getState(room);
  const candidates = state.voting?.candidates || {};
  const usersSnap = await db.ref(`rooms/${room}/users`).get();
  const charsSnap = await db.ref(`rooms/${room}/characters`).get();
  const users = usersSnap.exists()? usersSnap.val() : {};
  const chars = charsSnap.exists()? charsSnap.val() : {};
  const removeSel = byId('removeCandidateSelect');
  removeSel.innerHTML = '<option value="">— remove candidate —</option>';
  for (const key of Object.keys(candidates||{})){
    const u = users[key]; const charName = u && u.charId && chars[u.charId] ? chars[u.charId].name : '';
    const opt = document.createElement('option');
    opt.value = key; opt.textContent = u ? `${u.name}${charName? ' — '+charName:''}` : key;
    removeSel.appendChild(opt);
  }
}
byId('addCandidateBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  const uid = byId('candidatePlayerSelect').value;
  if (!uid) return;
  await db.ref(`rooms/${room}/state/voting/candidates/${uid}`).set(true);
  await refreshCandidateSelectors(); await renderAdminTally();
});
byId('removeCandidateBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  const uid = byId('removeCandidateSelect').value;
  if (!uid) return;
  await db.ref(`rooms/${room}/state/voting/candidates/${uid}`).remove();
  const votesSnap = await db.ref(`rooms/${room}/state/voting/votes`).get();
  if (votesSnap.exists()){
    const votes = votesSnap.val();
    for (const [voter, choice] of Object.entries(votes)){
      if (choice === uid) await db.ref(`rooms/${room}/state/voting/votes/${voter}`).remove();
    }
  }
  await refreshCandidateSelectors(); await renderAdminTally();
});

/* Admin Tally */
async function renderAdminTally(){
  const room = currentAdminRoom();
  const state = await getState(room);
  const voting = state.voting || {};
  const [usersSnap, charsSnap] = await Promise.all([
    db.ref(`rooms/${room}/users`).get(),
    db.ref(`rooms/${room}/characters`).get()
  ]);
  const users = usersSnap.exists()? usersSnap.val(): {};
  const chars = charsSnap.exists()? charsSnap.val(): {};
  const candidates = voting.candidates || {};
  const votes = voting.votes || {};
  const display = Object.keys(candidates).map(k=>{
    const u = users[k]; const charName = u && u.charId && chars[u.charId] ? chars[u.charId].name : '';
    return {key:k, label: u ? `${u.name}${charName? ' — '+charName:''}` : k};
  });
  const alive = Object.entries(users).filter(([uid,u])=>{
    const dead = u.dead || (u.charId && chars[u.charId]?.dead);
    return !dead;
  }).length;
  const tally = {};
  Object.entries(votes).forEach(([voter, choice])=>{
    const u = users[voter]; const aliveVoter = u && !u.dead && !(u.charId && chars[u.charId]?.dead);
    if (aliveVoter) tally[choice] = (tally[choice]||0)+1;
  });
  const lines = display.map(d=>`• ${d.label}: <b class="tally">${tally[d.key]||0}</b>`).join('<br>');
  byId('adminTallyBox').innerHTML = (alive? `<div class="muted">Alive voters: ${alive}</div>` : '') + (lines || 'No votes yet.');
}

/* Auto close voting */
function scheduleAutoClose(room, endsAt){
  const ms = Math.max(0, endsAt - Date.now());
  setTimeout(async ()=>{
    const state = await getState(room);
    if (state.voting?.open && state.voting.endsAt && Date.now() >= state.voting.endsAt){
      await closeVotingAndResolve(room, false);
    }
  }, ms + 1000);
}

/* Close vote, resolve, eliminate (≥50% of alive), popup */
async function closeVotingAndResolve(room, manual){
  const state = await getState(room);
  const voting = state.voting || {};
  if (!voting.open) return;
  await db.ref(`rooms/${room}/state/voting/open`).set(false);
  await db.ref(`rooms/${room}/state/voting/closed`).set(true);

  const [usersSnap, charsSnap] = await Promise.all([
    db.ref(`rooms/${room}/users`).get(),
    db.ref(`rooms/${room}/characters`).get()
  ]);
  const users = usersSnap.exists()? usersSnap.val(): {};
  const chars = charsSnap.exists()? charsSnap.val(): {};
  const votes = voting.votes || {};
  const aliveUsers = Object.entries(users).filter(([uid,u])=> !(u.dead || (u.charId && chars[u.charId]?.dead)));
  const aliveCount = aliveUsers.length;

  const tally = {};
  for (const [voter, choice] of Object.entries(votes)){
    const u = users[voter];
    const aliveVoter = u && !u.dead && !(u.charId && chars[u.charId]?.dead);
    if (aliveVoter) tally[choice] = (tally[choice]||0)+1;
  }
  let bestKey = null, bestCount = -1;
  Object.entries(tally).forEach(([k,c])=>{ if (c>bestCount){ bestKey=k; bestCount=c; }});
  const needed = Math.ceil(aliveCount * 0.5);
  let resultHtml = `<div>Alive voters: <b>${aliveCount}</b> • Threshold to eliminate: <b>${needed}</b></div><br>`;
  for (const [k,c] of Object.entries(tally)){
    const u = users[k];
    const label = u ? u.name : k;
    resultHtml += `• ${label}: <b class="tally">${c}</b><br>`;
  }
  if (bestKey && bestCount >= needed){
    const u = users[bestKey];
    if (u){
      await db.ref(`rooms/${room}/users/${bestKey}/dead`).set(true);
      if (u.charId) await db.ref(`rooms/${room}/characters/${u.charId}/dead`).set(true);
      resultHtml += `<br><b>Eliminated:</b> ${u.name} (by vote)`;
    }
  }else{
    resultHtml += `<br><b>No elimination.</b>`;
  }
  popup('Mob Justice — Results', resultHtml);
  await renderAdminTally();
  await checkWinConditions(room);
}

/* Win conditions */
async function checkWinConditions(room, extraMsg){
  const [usersSnap, charsSnap, stateSnap] = await Promise.all([
    db.ref(`rooms/${room}/users`).get(),
    db.ref(`rooms/${room}/characters`).get(),
    db.ref(`rooms/${room}/state`).get()
  ]);
  if (!usersSnap.exists()) return;
  const users = usersSnap.val();
  const chars = charsSnap.exists()? charsSnap.val(): {};
  const state = stateSnap.exists()? stateSnap.val(): {round:1};

  const aliveUsers = Object.values(users).filter(u=> !(u.dead || (u.charId && chars[u.charId]?.dead)));
  const aliveVamps = aliveUsers.filter(u=> ['Elder Vampire','Lesser Vampire'].includes(u.specialRole));
  const aliveNonVamps = aliveUsers.filter(u=> !['Elder Vampire','Lesser Vampire'].includes(u.specialRole));

  if (aliveVamps.length === 0){
    popup('Village Victory', `<div>The Elder and Lesser vampires are dead. The village prevails!${extraMsg? `<br><br><i>${extraMsg}</i>`:''}</div>`);
    return;
  }
  if (aliveVamps.length >= aliveNonVamps.length || (state.round>4 && aliveVamps.length>0)){
    popup('Vampires Triumph', `<div>The night belongs to fangs and shadow.${extraMsg? `<br><br><i>${extraMsg}</i>`:''}</div>`);
  }
}

/* CSV Import (Admin) */
function parseCSV(text){
  const rows=[]; let cur=''; let row=[]; let inq=false;
  for (let i=0;i<text.length;i++){
    const ch=text[i], nxt=text[i+1];
    if (ch==='\"'){
      if (inq && nxt==='\"'){ cur+='\"'; i++; }
      else inq=!inq;
    }else if (ch===',' && !inq){
      row.push(cur); cur='';
    }else if ((ch==='\n' || ch==='\r') && !inq){
      if (cur.length||row.length){ row.push(cur); rows.push(row); cur=''; row=[]; }
      if (ch==='\r' && nxt==='\n') i++;
    }else cur+=ch;
  }
  if (cur.length||row.length) { row.push(cur); rows.push(row); }
  return rows;
}

byId('importCharsBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  const file = byId('csvChars').files[0];
  if (!file){ byId('csvStatus').textContent='Select a characters CSV.'; return; }
  const txt = await file.text();
  const rows = parseCSV(txt).filter(r=>r.length>=1);
  const chars={}; let i=0;
  for (const r of rows){
    const name=(r[0]||'').trim(); if (!name) continue;
    const desc=(r[1]||'').trim()||null;
    const id='c_'+(i++).toString().padStart(3,'0');
    chars[id]={name: desc ? `${name} — ${desc}` : name, desc, claimedBy:null, claimedAt:null, dead:false};
  }
  if (!Object.keys(chars).length){ byId('csvStatus').textContent='No valid rows found.'; return; }
  await db.ref(`rooms/${room}/characters`).set(chars);
  byId('csvStatus').textContent='Characters imported.';
  await renderAdminTally(); await refreshPlayerDropdowns();
});

byId('useDefaultCharsBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  const chars={}; DEFAULT_CHAR_OBJS.forEach((o,i)=>{
    const id='c_'+i.toString().padStart(3,'0');
    const combined = o.desc ? `${o.name} — ${o.desc}` : o.name;
    chars[id]={name:combined, desc:o.desc||null, claimedBy:null, claimedAt:null, dead:false};
  });
  await db.ref(`rooms/${room}/characters`).set(chars);
  byId('csvStatus').textContent='Default characters loaded.';
  await renderAdminTally(); await refreshPlayerDropdowns();
});

byId('importCluesBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  const file = byId('csvClues').files[0];
  if (!file){ byId('csvStatus').textContent='Select a clues CSV.'; return; }
  const txt = await file.text();
  const rows = parseCSV(txt).filter(r=>r.length>=3);
  const clues={};
  for (const r of rows){
    const id=(r[0]||'').trim(); const title=(r[1]||'').trim(); const body=(r[2]||'').trim();
    if (!id || !title || !body) continue;
    clues[id]={title, body, revealed:false};
  }
  if (!Object.keys(clues).length){ byId('csvStatus').textContent='No valid clue rows found.'; return; }
  await db.ref(`rooms/${room}/clues`).set(clues);
  byId('csvStatus').textContent='Clues imported.';
});

byId('useDefaultCluesBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  const clues={}; DEFAULT_CLUES.forEach(c=> clues[c.id]={title:c.title, body:c.body, revealed:false});
  await db.ref(`rooms/${room}/clues`).set(clues);
  byId('csvStatus').textContent='Default clues loaded.';
});

/* Collapse UI to Active for players with a character */
function collapseToActiveOnly(){
  const isAdminUnlocked = localStorage.getItem('mb_is_admin') === '1';
  // Hide tabs for regular players; show tabs for admin device
  if (!isAdminUnlocked) byId('topTabs').classList.add('hidden');
  // Show only the Active panel
  document.getElementById('panel-active').hidden = false;
  ['panel-host','panel-join','panel-clues','panel-admin'].forEach(id=>{
    const el = document.getElementById(id); if (el) el.hidden = true;
  });
}

/* Prefill from cookies; show active if already assigned */
(function(){
  const r = getCookie('mb_room'); const n = getCookie('mb_name');
  if (r) byId('joinRoom').value = r;
  if (n) byId('realName').value = n;
})();
document.addEventListener('DOMContentLoaded', ()=>{
  if (localStorage.getItem('mb_charId')) collapseToActiveOnly();
  refreshActive();
});
</script>
</body>
</html>
