<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Moonlit Bandanas ‚Äî Game Hub</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Inter:wght@400;600&family=Crimson+Text:wght@400;700&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#0b0b0d; --panel:#131316; --ink:#ececf2; --muted:#a1a1aa;
    --accent:#b11226; --accent2:#e01e37; --ring:0 0 0 2px rgba(224,30,55,.25);
  }
  *{box-sizing:border-box} html,body{height:100%}
  body{
    margin:0;
    background:
      radial-gradient(1200px 600px at 80% -10%, rgba(224,30,55,.10), transparent 60%),
      radial-gradient(800px 500px at -10% 80%, rgba(224,30,55,.08), transparent 60%),
      var(--bg);
    color:var(--ink); font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif;
  }
  header{padding:28px 20px 8px; text-align:center}
  .title{font-family:Cinzel,serif; font-weight:700; font-size:clamp(26px,3.2vw,40px); text-shadow:0 0 30px rgba(224,30,55,.25)}
  .subtitle{color:var(--muted); margin-top:6px}
  .wrap{max-width:1100px; margin:0 auto; padding:20px}
  .tabs{display:flex; gap:8px; justify-content:center; margin:16px 0 24px; flex-wrap:wrap}
  .tab{border:1px solid #26262b; background:#121215; color:#d7d7de; padding:10px 14px; border-radius:12px; cursor:pointer}
  .tab[aria-selected="true"]{background:#201116; border-color:#531018; color:#ffd9dd; box-shadow:0 0 24px rgba(177,18,38,.35)}
  .panel{background:linear-gradient(180deg,#121215,#0f0f12); border:1px solid #242428; border-radius:16px; padding:18px}
  .grid{display:grid; gap:16px}
  @media(min-width:980px){.grid-2{grid-template-columns:1.2fr .8fr}}
  label{display:block; font-weight:600; margin:12px 0 6px}
  input, textarea, select{
    width:100%; background:#0d0d10; border:1px solid #26262b; color:#ececf2; border-radius:12px; padding:10px 12px; outline:none; font-size:15px
  }
  input:focus,textarea:focus,select:focus{border-color:#5f101a; box-shadow:var(--ring)}
  textarea{min-height:140px; resize:vertical}
  .btn{display:inline-flex; gap:8px; align-items:center; justify-content:center; background:linear-gradient(180deg,var(--accent2),var(--accent)); color:#fff; border:none; padding:11px 16px; border-radius:12px; cursor:pointer; font-weight:700; box-shadow:0 6px 24px rgba(224,30,55,.25)}
  .btn.secondary{background:#17171b; color:#f0e9eb; border:1px solid #2a2a30; box-shadow:none; font-weight:600}
  .muted{color:var(--muted); font-size:13px}
  .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  .badge{display:inline-block; padding:6px 10px; border-radius:999px; border:1px solid #2a2a30; color:#ececf2; font-size:13px; background:#111114}
  .success{border-color:#224a2b; background:linear-gradient(180deg,#102114,#0d1610); color:#c5f2d1}
  .danger{border-color:#5a0c15; background:linear-gradient(180deg,#1c0b0d,#12080a); color:#ffd9de}
  .info{border-color:#0e3f56; background:linear-gradient(180deg,#0b151a,#0a1317); color:#c8e5f3}
  .divider{height:1px; background:#222226; margin:14px 0}
  .card{background:linear-gradient(180deg,#121215,#0f0f12); border:1px solid #242428; border-radius:16px; padding:14px}
  .mono{font-family:ui-monospace,Menlo,Monaco,Consolas,monospace}
  .center{text-align:center}
  .pill{padding:6px 10px; border-radius:999px; background:#151518; border:1px solid #2a2a30; font-size:12px}

  /* Burned parchment */
  .parchment{
    color:#20160f;
    border:1px solid #3a2a1f;
    border-radius:14px;
    padding:14px 16px;
    font-family:"Crimson Text","Times New Roman",serif;
    box-shadow:0 10px 30px rgba(0,0,0,.45), inset 0 0 24px rgba(0,0,0,.35);
    background:
      radial-gradient(140% 100% at 0% 0%, rgba(0,0,0,.18), transparent 40%),
      radial-gradient(140% 100% at 100% 100%, rgba(0,0,0,.16), transparent 40%),
      radial-gradient(200px 80px at 10% 20%, rgba(70,35,20,.35), transparent 60%),
      radial-gradient(200px 80px at 90% 80%, rgba(70,35,20,.30), transparent 60%),
      repeating-linear-gradient(0deg, rgba(0,0,0,.035), rgba(0,0,0,.035) 2px, transparent 2px, transparent 4px),
      linear-gradient(180deg, #3a2b1f, #2f231a 60%, #2b2118);
    position:relative;
  }
  .parchment:before{
    content:""; position:absolute; inset:-6px; border-radius:18px;
    background:
      radial-gradient(200px 60px at 5% 10%, rgba(0,0,0,.65), transparent 50%),
      radial-gradient(240px 80px at 95% 90%, rgba(0,0,0,.6), transparent 50%),
      radial-gradient(800px 220px at 50% -40px, rgba(0,0,0,.5), transparent 60%),
      radial-gradient(800px 220px at 50% calc(100% + 40px), rgba(0,0,0,.5), transparent 60%);
    pointer-events:none; mix-blend-mode:multiply; opacity:.6; filter: blur(1px);
  }
  .parchment h4{margin:.3rem 0 .2rem; font-size:18px; color:#f2e7d9}
  .parchment .tag{font-size:12px; color:#bda48f}

  /* Checklist */
  .todo{display:flex; align-items:flex-start; gap:10px; padding:10px 12px; border:1px solid #242428; border-radius:12px; margin-top:8px; background:#101014}
  .todo input[type="checkbox"]{transform:scale(1.2); margin-top:3px}
  .todo.done{opacity:.7}
  .kicker{font-family:Cinzel,serif; font-weight:700; letter-spacing:.4px}

  /* Vote list */
  .vote-list{display:grid; gap:8px}
  .vote-item{display:flex; align-items:center; gap:10px; padding:8px 10px; border:1px solid #242428; border-radius:10px; background:#0f0f13}
  .tally{font-variant-numeric:tabular-nums}

  /* Modal */
  dialog{border:none; border-radius:16px; padding:0; max-width:640px; width:calc(100% - 24px); background:#151519; color:#f0eef3; box-shadow:0 30px 80px rgba(0,0,0,.6)}
  .modal-head{padding:16px 18px; background:#1a0f13; border-bottom:1px solid #2b0e15; font-family:Cinzel,serif}
  .modal-body{padding:16px 18px}
  .modal-actions{padding:12px 18px; display:flex; justify-content:flex-end; gap:10px; border-top:1px solid #232327}
</style>
</head>
<body>
<header>
  <div class="title">Moonlit Bandanas</div>
  <div class="subtitle">Assignments ‚Ä¢ Active Mode ‚Ä¢ Clues ‚Ä¢ Mob Justice</div>
</header>

<div class="wrap">
  <nav class="tabs" role="tablist" aria-label="Moonlit App">
    <button class="tab" id="tab-host" role="tab" aria-selected="true">Host Setup</button>
    <button class="tab" id="tab-join" role="tab" aria-selected="false">Join</button>
    <button class="tab" id="tab-active" role="tab" aria-selected="false">Active Mode</button>
    <button class="tab" id="tab-clues" role="tab" aria-selected="false">Clues</button>
    <button class="tab" id="tab-admin" role="tab" aria-selected="false">Admin</button>
  </nav>

  <!-- HOST SETUP -->
  <section id="panel-host" class="panel" role="tabpanel" aria-labelledby="tab-host">
    <div class="grid grid-2">
      <div>
        <label>Room Code</label>
        <input id="roomCode" placeholder="e.g., REVEL-2025" />
        <div class="muted">Letters/numbers/dashes (3‚Äì30 chars).</div>

        <label style="margin-top:12px">Room Password</label>
        <input id="roomPassword" type="password" placeholder="Password players must enter" />
        <div class="muted">Stored as SHA-256 hash.</div>

        <label style="margin-top:12px">Admin Password (secret)</label>
        <input id="roomAdminPassword" type="password" placeholder="Required to unlock Admin" />
        <div class="muted">Stored as SHA-256 hash.</div>

        <div class="divider"></div>

        <label>Character Pool (one per line)</label>
        <textarea id="rolePool"></textarea>

        <div class="divider"></div>

        <div class="row">
          <button class="btn" id="createRoomBtn">Create / Reset Room</button>
          <button class="btn secondary" id="fillDefaultsBtn">Reset To Default Characters</button>
        </div>
        <div id="hostStatus" style="margin-top:10px"></div>
      </div>

      <div class="card">
        <b>How it works</b>
        <ul>
          <li>Host creates a room with passwords.</li>
          <li>Players join and receive a random unclaimed character.</li>
          <li>Active Mode tracks tasks; Clues appear as they‚Äôre revealed.</li>
          <li>Mob Justice votes, death toggles, and rounds are controlled by the Admin.</li>
        </ul>
      </div>
    </div>
  </section>

  <!-- JOIN -->
  <section id="panel-join" class="panel" role="tabpanel" aria-labelledby="tab-join" hidden>
    <div class="grid">
      <div>
        <label>Room Code</label>
        <input id="joinRoom" placeholder="Enter room code exactly" />
      </div>
      <div>
        <label>Room Password</label>
        <input id="joinPass" type="password" placeholder="Enter the room password" />
      </div>
      <div>
        <label>Your Real Name</label>
        <input id="realName" placeholder="e.g., Alex Johnson" />
      </div>
      <div class="row">
        <button class="btn" id="assignBtn">Get My Character</button>
        <button class="btn secondary" id="revealMineBtn">Reveal Mine Again</button>
      </div>
      <div id="assignStatus"></div>

      <div id="myRoleCard" class="card" style="display:none; margin-top:12px">
        <div class="row"><span class="badge success">Assigned</span></div>
        <h3 id="roleName" style="margin:8px 0 6px; font-family:Cinzel,serif"></h3>
        <div class="muted">See Active Mode for your checklist and voting.</div>
        <div class="row" style="margin-top:10px">
          <button class="btn secondary" id="copyRoleBtn">Copy to Clipboard</button>
        </div>
      </div>
    </div>
  </section>

  <!-- ACTIVE MODE -->
  <section id="panel-active" class="panel" role="tabpanel" aria-labelledby="tab-active" hidden>
    <div class="grid">
      <div class="row" style="justify-content:space-between">
        <div class="row" style="gap:12px">
          <span class="pill" id="activeRoomPill">Room: ‚Äî</span>
          <span class="pill" id="activeNamePill">Player: ‚Äî</span>
          <span class="pill" id="activeCharPill">Character: ‚Äî</span>
          <span class="pill" id="activeRolePill">Special: (none)</span>
          <span class="pill" id="roundPill">Round: ‚Äî</span>
          <span class="pill" id="voteStatusPill">Vote: ‚Äî</span>
          <span class="pill" id="voteCountdownPill">‚è≥ ‚Äî</span>
        </div>
        <button class="btn secondary" id="refreshActiveBtn">Refresh</button>
      </div>

      <div class="divider"></div>

      <div class="grid grid-2">
        <div>
          <h3 class="kicker">Your Objectives</h3>
          <div id="todoList" class="muted">‚Äî</div>
        </div>
        <div>
          <h3 class="kicker">Notes (private)</h3>
          <textarea id="notesBox" placeholder="Jot suspects, alibis, or reminders‚Ä¶ (saved on this device)"></textarea>
          <div class="row" style="margin-top:8px">
            <button class="btn secondary" id="saveNotesBtn">Save Notes</button>
            <span class="muted">Notes are not uploaded.</span>
          </div>
        </div>
      </div>

      <div class="divider"></div>

      <!-- MOB JUSTICE (player) -->
      <div class="card">
        <h3 class="kicker">Mob Justice</h3>
        <div id="voteBlock">
          <div class="muted" id="voteHelp">Waiting for Admin to open voting‚Ä¶</div>
          <div id="candidateList" class="vote-list" style="margin-top:8px"></div>
          <div class="row" style="margin-top:10px">
            <button class="btn" id="castVoteBtn">Cast / Update Vote</button>
            <span class="muted">One vote per round; you can change it until voting closes.</span>
          </div>
          <div class="divider"></div>
          <div id="tallyBox" class="muted"></div>
        </div>
      </div>
    </div>
  </section>

  <!-- CLUES -->
  <section id="panel-clues" class="panel" role="tabpanel" aria-labelledby="tab-clues" hidden>
    <div class="grid">
      <div class="row" style="gap:12px">
        <span class="pill">Revealed Clues</span>
        <button class="btn secondary" id="refreshCluesBtn">Refresh</button>
      </div>
      <div id="clueList" class="grid" style="gap:14px; margin-top:8px">
        <div class="muted">No clues revealed yet.</div>
      </div>
    </div>
  </section>

  <!-- ADMIN -->
  <section id="panel-admin" class="panel" role="tabpanel" aria-labelledby="tab-admin" hidden>
    <div class="grid">
      <div class="card">
        <b>Admin Access</b>
        <div class="row" style="gap:12px; margin-top:8px">
          <div style="flex:1">
            <label>Room Code</label>
            <input id="adminRoom" placeholder="Room code" />
          </div>
          <div style="flex:1">
            <label>Admin Password</label>
            <input id="adminPass" type="password" placeholder="Admin password" />
          </div>
          <button class="btn" id="adminAuthBtn">Unlock Admin</button>
          <div id="adminAuthStatus"></div>
        </div>
      </div>

      <div class="grid grid-2">
        <div class="card">
          <h3>Characters</h3>
          <div class="row" style="gap:12px; flex-wrap:wrap">
            <button class="btn secondary" id="loadRoomBtn">Load Lists</button>
            <button class="btn secondary" id="watchRoomBtn">Live Watch</button>
            <select id="deadToggleSelect"><option value="">‚Äî select claimed player ‚Äî</option></select>
            <button class="btn" id="markDeadBtn">Mark Dead</button>
            <button class="btn secondary" id="markAliveBtn">Mark Alive</button>
          </div>
          <div class="divider"></div>
          <h4>Unclaimed</h4>
          <div id="unclaimedBox" class="muted">‚Äî</div>
          <div class="divider"></div>
          <h4>Claimed</h4>
          <div id="claimedBox" class="muted">‚Äî</div>
        </div>

        <div class="card">
          <h3>Assign Special Roles</h3>
          <div class="muted">Select a claimed player and assign.</div>
          <div class="row" style="gap:12px; margin-top:8px">
            <select id="playerSelect"><option value="">‚Äî select player ‚Äî</option></select>
            <select id="specialSelect">
              <option value="">(none)</option>
              <option>Elder Vampire</option>
              <option>Lesser Vampire</option>
              <option>Thrall</option>
              <option>Night Warden</option>
              <option>Mirrorcloak</option>
              <option>Gravespeaker</option>
            </select>
            <button class="btn" id="assignSpecialBtn">Assign</button>
          </div>
          <div id="specialStatus" style="margin-top:8px"></div>
        </div>
      </div>

      <!-- ROUND & VOTING CONTROLS -->
      <div class="card">
        <h3>Round & Mob Justice Controls</h3>
        <div class="row" style="gap:10px; align-items:flex-end">
          <div>
            <label>Round</label>
            <input id="adminRoundDisplay" disabled />
          </div>
          <button class="btn" id="nextRoundBtn">Advance to Next Round</button>
        </div>

        <div class="divider"></div>

        <div class="row" style="gap:10px; align-items:flex-end; flex-wrap:wrap">
          <div>
            <label>Voting Status</label>
            <input id="votingStatusDisplay" disabled />
          </div>
          <button class="btn secondary" id="start5minVoteBtn">Start 5-Minute Vote</button>
          <button class="btn secondary" id="openVotingBtn">Open Voting</button>
          <button class="btn secondary" id="closeVotingBtn">Close Voting</button>
          <button class="btn secondary" id="clearVotingBtn">Clear Candidates & Votes</button>
        </div>

        <div class="divider"></div>

        <div class="row" style="gap:10px; align-items:flex-end; flex-wrap:wrap">
          <select id="candidatePlayerSelect"><option value="">‚Äî add candidate (claimed players) ‚Äî</option></select>
          <button class="btn" id="addCandidateBtn">Add Candidate</button>
          <select id="removeCandidateSelect"><option value="">‚Äî remove candidate ‚Äî</option></select>
          <button class="btn secondary" id="removeCandidateBtn">Remove</button>
        </div>

        <div class="divider"></div>

        <div id="adminTallyBox" class="muted">No votes yet.</div>
      </div>

      <!-- CSV IMPORT -->
      <div class="card">
        <h3>Import via CSV</h3>
        <div class="row" style="gap:14px; align-items:flex-end; flex-wrap:wrap">
          <div>
            <label>Characters CSV (name,description)</label>
            <input id="csvChars" type="file" accept=".csv" />
          </div>
          <button class="btn" id="importCharsBtn">Import Characters</button>
          <button class="btn secondary" id="useDefaultCharsBtn">Use Default Characters</button>
        </div>
        <div class="divider"></div>
        <div class="row" style="gap:14px; align-items:flex-end; flex-wrap:wrap">
          <div>
            <label>Clues CSV (id,title,body)</label>
            <input id="csvClues" type="file" accept=".csv" />
          </div>
          <button class="btn" id="importCluesBtn">Import Clues</button>
          <button class="btn secondary" id="useDefaultCluesBtn">Use Default Clues</button>
        </div>
        <div class="muted" id="csvStatus" style="margin-top:8px"></div>
      </div>
    </div>
  </section>

  <p class="center muted" style="margin:18px 0 40px">
    Theme: reds & blacks ‚Ä¢ Burned parchment clues ‚Ä¢ Mob Justice voting ‚Ä¢ Good hunting ü©∏
  </p>
</div>

<!-- Result modal -->
<dialog id="resultModal">
  <div class="modal-head" id="modalTitle">Result</div>
  <div class="modal-body" id="modalBody"></div>
  <div class="modal-actions">
    <button class="btn secondary" id="closeModalBtn">Close</button>
  </div>
</dialog>

<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-database-compat.js"></script>

<script>
/* Tabs */
const TABS = [
  {btn:'tab-host',   panel:'panel-host'},
  {btn:'tab-join',   panel:'panel-join'},
  {btn:'tab-active', panel:'panel-active'},
  {btn:'tab-clues',  panel:'panel-clues'},
  {btn:'tab-admin',  panel:'panel-admin'},
];
TABS.forEach(({btn,panel})=>{
  document.getElementById(btn).addEventListener('click', ()=>{
    TABS.forEach(x=>{
      document.getElementById(x.btn).setAttribute('aria-selected', x.btn===btn ? 'true':'false');
      document.getElementById(x.panel).hidden = x.panel!==panel;
    });
  });
});

/* Defaults */
const CHARACTERS = [
"V. M. Pyre ‚Äî Fire-eater & matchbook collector",
"Ashen Vale ‚Äî Traveling apothecary",
"Gloom Ivy ‚Äî Lantern carver",
"Hex Rowan ‚Äî Fortune-maker with dice",
"Noct Rune ‚Äî Night watch scribe",
"Cinder Wight ‚Äî Glassblower",
"Marrow Quinn ‚Äî Anatomist & sketcher",
"Ebon Thatch ‚Äî Innkeeper",
"Sable Nyx ‚Äî Perfumer",
"Thorn Ever ‚Äî Debt-keeper",
"Cob Webber ‚Äî Trap-maker",
"Hallow Reed ‚Äî Folk singer",
"Mist Graves ‚Äî Sleep-walker",
"Piper Shade ‚Äî Flute-seller",
"Rune Lantern ‚Äî Tinker of lights",
"Bramble Kite ‚Äî Messenger",
"Frost Morn ‚Äî Ice seller",
"Ember Hollow ‚Äî Candlemaker",
"Wisp Harrow ‚Äî Story collector",
"Crypt Alder ‚Äî Quartermaster",
"Omen Lark ‚Äî Oracle busker",
"Raven Cask ‚Äî Brewer of odd ales",
"Night Jar ‚Äî Curio dealer",
"Lumen Wolfe ‚Äî Town watch volunteer",
"Patch Wylde ‚Äî Card-sharp",
"Echo Vane ‚Äî Rumor broker",
"Dusk Mariner ‚Äî Ferrier of the bog",
"Ivy Haze ‚Äî Herb gatherer",
"Slate Crowe ‚Äî Record keeper",
"Gourd Wilder ‚Äî Mask artisan"
];

const DEFAULT_TASKS = [
  "Learn two names and one hobby.",
  "Trade a small trinket or token with someone.",
  "Share one rumor or clue you‚Äôve heard.",
  "Publicly vouch for or accuse exactly one person."
];

const DEFAULT_CLUES = [
  {id:"E1", title:"The Dimming of Candles", body:"In the glassblower‚Äôs stall, a trio of candles guttered all at once, as though a mouth had drawn in the room‚Äôs breath. Witnesses swore the figure who passed by wore a ring that drank the light. They left no soot, only a whisper of clove."},
  {id:"E2", title:"The Whispering Step", body:"Near the square of empty masks, a watcher heard footfalls that seemed to land after their own echoes. The gait was even, decisive, and oddly weightless‚Äîas if the night itself cushioned each stride."},
  {id:"E3", title:"Threads by the Well", body:"By the old wishing well, a single thread of deep red snagged on weathered stone, the shade of a harvest moon. No cloak nearby bore that hue‚Äîperhaps it belonged to a sash tied close to the heart."},
  {id:"E4", title:"The Breath That Wasn‚Äôt", body:"Flutes lay in their case, and yet a mourning note hung in the air as if blown by no mouth at all. The player who lingered exhaled fog though the night was warm, and smiled without teeth."},
  {id:"E5", title:"The Lantern That Blinked", body:"A tinker‚Äôs lantern fluttered near a laughing circle‚Äîthen steadied when a single figure drew near and asked no questions. Lies make it flicker, the tinker swears."},
  {id:"E6", title:"A Toast to Nowhere", body:"Someone raised an empty cup and murmured a phrase not quite language, not quite song. Those within earshot forgot a name they had just learned. The smell of old cellars followed."},
  {id:"E7", title:"Left Hand of Dusk", body:"Chalk tallies were scrawled backward on a ledger margin, lines neat yet mirrored. Whoever wrote them favored the left hand and the calm of twilight."},
  {id:"E8", title:"The Silver Coin Gone Cold", body:"A coin traded thrice in an hour turned cold enough to mist a mirror. The last to hold it tucked it away with clinical care, as though cataloging a specimen."},
  {id:"L1", title:"The Heir in the Crowd", body:"When the bells tolled, a shadow took shelter in another‚Äôs laughter. The heir does not stand alone; they orbit a brighter star to dim their edges."},
  {id:"L2", title:"The Smile That Stops", body:"A chuckle rang out, crisp as cracked ice, but ended sharply‚Äîhabit, not humor. Hands drifted to pockets where keys or coins clicked in nervous code."},
  {id:"L3", title:"Scent of Wet Stone", body:"On the path to the bog ferries, a scent of wet stone trailed someone who avoids shallow water, preferring docks‚Äô deeper quiet."},
  {id:"L4", title:"The Double Shadow", body:"Two silhouettes overlapped beneath a single lantern: one tall and still, the other shifting, impatient. Only one turned when hailed."},
  {id:"L5", title:"The Hat with No Owner", body:"A brim with a feather of ash-gray was left on a chair that always faces the door. No one claimed it‚Äîbut more than one person looked too long at its seat."},
  {id:"L6", title:"Ink Under the Nail", body:"A knuckle brushed paper and left a crescent of black under the nail‚Äîold ink that no wash could fully banish."},
  {id:"D1", title:"Red Herring: The Laughing Mask", body:"A maskmaker insisted a mask smiled on its own when a brewer sang off-key. Sweet nonsense, perhaps, or theater."},
  {id:"D2", title:"Red Herring: The Garlic Fable", body:"Someone swore they saw a cloaked patron recoil from garlic‚Ä¶ but the cloves were candied. Theatrical groaning followed."}
];

/* Firebase */
const firebaseConfig = {
  apiKey: "AIzaSyDNqVMgr5CHIe-ajgikCaJp0kzB2CpbOWs",
  authDomain: "murdermystery-cd241.firebaseapp.com",
  databaseURL: "https://murdermystery-cd241-default-rtdb.firebaseio.com",
  projectId: "murdermystery-cd241",
  storageBucket: "murdermystery-cd241.firebasestorage.app",
  messagingSenderId: "724748560349",
  appId: "1:724748560349:web:4ba1d4f5ed874419167834",
  measurementId: "G-7RS065D3HZ"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.database();

/* Helpers & modal */
const byId = id => document.getElementById(id);
const setPill = (id,t)=> byId(id).textContent = t;
const hashSHA256 = async (text)=>{
  const enc = new TextEncoder().encode(text);
  const buf = await crypto.subtle.digest('SHA-256', enc);
  return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join('');
};
function setCookie(name,value,days){
  const d = new Date(); d.setTime(d.getTime() + (days*24*60*60*1000));
  document.cookie = `${name}=${encodeURIComponent(value)}; expires=${d.toUTCString()}; path=/; SameSite=Lax`;
}
function getCookie(name){
  const m = document.cookie.match(new RegExp('(^| )'+name+'=([^;]+)')); return m ? decodeURIComponent(m[2]) : '';
}
function showAdminTab(visible){
  const btn = byId('tab-admin'), panel = byId('panel-admin');
  btn.style.display = visible ? '' : 'none';
  if (!visible) panel.hidden = true;
}
showAdminTab(localStorage.getItem('mb_pass_admin_ok') === '1');

const modal = byId('resultModal');
byId('closeModalBtn').addEventListener('click', ()=> modal.close());
function popup(title, html){
  byId('modalTitle').textContent = title;
  byId('modalBody').innerHTML = html;
  modal.showModal();
}

/* Host Setup */
const rolePoolEl = byId('rolePool');
byId('fillDefaultsBtn').addEventListener('click', ()=>{ rolePoolEl.value = CHARACTERS.join("\n"); });
byId('fillDefaultsBtn').click();

byId('createRoomBtn').addEventListener('click', async ()=>{
  const codeRaw = (byId('roomCode').value||'').trim();
  const passRaw = (byId('roomPassword').value||'').trim();
  const adminPassRaw = (byId('roomAdminPassword').value||'').trim();
  const hostStatus = byId('hostStatus');
  if (!/^[A-Za-z0-9-]{3,30}$/.test(codeRaw)){ hostStatus.innerHTML = `<span class="badge danger">Invalid room code</span>`; return; }
  if (!passRaw || passRaw.length < 4){ hostStatus.innerHTML = `<span class="badge danger">Room password too short</span>`; return; }
  if (!adminPassRaw || adminPassRaw.length < 6){ hostStatus.innerHTML = `<span class="badge danger">Admin password too short</span>`; return; }
  const code = codeRaw.toUpperCase();
  const passHash = await hashSHA256(passRaw);
  const adminHash = await hashSHA256(adminPassRaw);
  const lines = (rolePoolEl.value||'').split('\n').map(s=>s.trim()).filter(Boolean);
  const unique = [...new Set(lines)];
  if (!unique.length){ hostStatus.innerHTML = `<span class="badge danger">No characters provided</span>`; return; }
  const chars = {};
  unique.forEach((line, i)=>{
    const [name] = line.split('‚Äî'); // name ‚Äî desc (optional visual)
    const id = 'c_'+i.toString().padStart(3,'0');
    chars[id] = {name: line, desc: null, claimedBy:null, claimedAt:null, dead:false};
  });
  const clues = {}; DEFAULT_CLUES.forEach(c=>{ clues[c.id] = {title:c.title, body:c.body, revealed:false}; });
  const state = { round: 1, voting: { open:false, closed:false, candidates:null, votes:null, endsAt:null } };
  try{
    await db.ref(`rooms/${code}`).set({
      passHash, adminHash, createdAt: Date.now(),
      characters: chars, users: null, clues, state
    });
    hostStatus.innerHTML = `<span class="badge success">Room ready</span> <b class="mono">${code}</b>`;
    localStorage.setItem('mb_room_host', code);
  }catch(e){
    hostStatus.innerHTML = `<span class="badge danger">Error</span> ${e.message}`;
  }
});

/* Join & Claim */
function saveLocal(room,name,charId,charName){
  localStorage.setItem('mb_room', room);
  localStorage.setItem('mb_name', name);
  localStorage.setItem('mb_charId', charId);
  localStorage.setItem('mb_charName', charName);
}
function getUid(room,name){ return btoa(`${name}::${room}`).replace(/=+$/,''); }
async function verifyRoomPassword(room, pass){
  const snap = await db.ref(`rooms/${room}/passHash`).get();
  if (!snap.exists()) throw new Error('Room not found');
  return (await hashSHA256(pass)) === snap.val();
}

async function claimCharacter(room, pass, realName){
  const r = room.toUpperCase();
  const ok = await verifyRoomPassword(r, pass);
  if (!ok) throw new Error('Incorrect password');
  const rolesSnap = await db.ref(`rooms/${r}/characters`).get();
  if (!rolesSnap.exists()) throw new Error('No characters in this room');
  const entries = Object.entries(rolesSnap.val());
  const unclaimed = entries.filter(([id,c])=>!c.claimedBy).map(([id,c])=>({id,name:c.name}));
  if (!unclaimed.length) throw new Error('All characters are taken');
  const pick = unclaimed[Math.floor(Math.random()*unclaimed.length)];
  const ref = db.ref(`rooms/${r}/characters/${pick.id}`);
  const res = await new Promise((resolve, reject)=>{
    ref.transaction(curr=>{
      if (!curr) return curr;
      if (curr.claimedBy) return;
      return {...curr, claimedBy: realName, claimedAt: Date.now()};
    }, (error, committed, snapshot)=>{
      if (error) return reject(error);
      resolve({committed, snapshot});
    }, false);
  });
  if (!res.committed) return claimCharacter(r, pass, realName);

  const uid = getUid(r, realName);
  await new Promise((resolve, reject)=>{
    db.ref(`rooms/${r}/users/${uid}`).transaction(curr=>{
      if (curr) return curr;
      return {
        name: realName,
        charId: pick.id,
        specialRole: null,
        tasks: DEFAULT_TASKS.map(t=>({text:t, done:false})),
        dead:false
      };
    }, (error, committed)=>{
      if (error) return reject(error);
      resolve(committed);
    }, false);
  });
  saveLocal(r, realName, pick.id, pick.name);
  setCookie('mb_room', r, 30);
  setCookie('mb_name', realName, 30);
  return pick.name;
}

byId('assignBtn').addEventListener('click', async ()=>{
  const room = (byId('joinRoom').value||'').trim();
  const pass = (byId('joinPass').value||'').trim();
  const name = (byId('realName').value||'').trim();
  const status = byId('assignStatus');
  if (!room || !pass || !name){ status.innerHTML = `<span class="badge danger">Enter room, password, and name</span>`; return; }
  status.textContent = 'Assigning‚Ä¶';
  try{
    const charName = await claimCharacter(room, pass, name);
    status.innerHTML = `<span class="badge success">Assigned</span>`;
    byId('roleName').textContent = `${charName} ‚Äî assigned to ${name}`;
    byId('myRoleCard').style.display = '';
    collapseToActiveOnly();
    refreshActive();
  }catch(e){
    status.innerHTML = `<span class="badge danger">Error</span> ${e.message}`;
  }
});

byId('revealMineBtn').addEventListener('click', async ()=>{
  const room = (byId('joinRoom').value||'').trim().toUpperCase();
  const pass = (byId('joinPass').value||'').trim();
  const name = (byId('realName').value||'').trim();
  const status = byId('assignStatus');
  if (!room || !pass || !name){ status.innerHTML=`<span class="badge danger">Enter room, password, and name</span>`; return; }
  try{
    const ok = await verifyRoomPassword(room, pass);
    if (!ok) throw new Error('Incorrect password');
    const uid = getUid(room, name);
    const uSnap = await db.ref(`rooms/${room}/users/${uid}`).get();
    if (!uSnap.exists()){ status.innerHTML=`<span class="badge danger">No prior assignment</span>`; return; }
    const {charId} = uSnap.val();
    const rSnap = await db.ref(`rooms/${room}/characters/${charId}`).get();
    const charName = rSnap.exists() ? rSnap.val().name : '(unknown)';
    saveLocal(room, name, charId, charName);
    setCookie('mb_room', room, 30);
    setCookie('mb_name', name, 30);
    byId('roleName').textContent = `${charName} ‚Äî assigned to ${name}`;
    byId('myRoleCard').style.display = '';
    status.innerHTML = `<span class="badge success">Found</span>`;
    collapseToActiveOnly();
    refreshActive();
  }catch(e){
    status.innerHTML = `<span class="badge danger">Error</span> ${e.message}`;
  }
});

byId('copyRoleBtn').addEventListener('click', async ()=>{
  const txt = byId('roleName').textContent;
  try{ await navigator.clipboard.writeText(txt); }catch{}
  alert('Copied:\n'+txt);
});

/* Active Mode */
function loadLocalIdentity(){
  return {
    room: localStorage.getItem('mb_room') || '',
    name: localStorage.getItem('mb_name') || '',
    charId: localStorage.getItem('mb_charId') || '',
    charName: localStorage.getItem('mb_charName') || '',
  };
}
async function getRoomState(room){
  const snap = await db.ref(`rooms/${room}/state`).get();
  if (!snap.exists()) return { round:1, voting:{open:false,closed:false,candidates:null,votes:null,endsAt:null} };
  return snap.val();
}

async function refreshActive(){
  const {room,name,charId,charName} = loadLocalIdentity();
  setPill('activeRoomPill', `Room: ${room||'‚Äî'}`);
  setPill('activeNamePill', `Player: ${name||'‚Äî'}`);
  setPill('activeCharPill', `Character: ${charName||'‚Äî'}`);

  if (!room || !name){ byId('todoList').innerHTML = '‚Äî'; setPill('activeRolePill','Special: (none)'); setPill('roundPill','Round: ‚Äî'); setPill('voteStatusPill','Vote: ‚Äî'); setPill('voteCountdownPill','‚è≥ ‚Äî'); return; }

  const uid = getUid(room, name);
  const [userSnap, state] = await Promise.all([
    db.ref(`rooms/${room}/users/${uid}`).get(),
    getRoomState(room)
  ]);
  setPill('roundPill', `Round: ${state.round||1}`);
  const voting = state.voting || {};
  setPill('voteStatusPill', `Vote: ${voting.open ? 'OPEN' : (voting.closed ? 'CLOSED' : '‚Äî')}`);
  updateCountdownPill(voting.endsAt);

  if (!userSnap.exists()){ byId('todoList').innerHTML='‚Äî'; setPill('activeRolePill','Special: (none)'); return; }
  const u = userSnap.val();
  setPill('activeRolePill', `Special: ${u.specialRole || '(none)'}`);

  const list = (u.tasks||[]).map((t,i)=>`
    <div class="todo ${t.done?'done':''}">
      <input type="checkbox" data-ix="${i}" ${t.done?'checked':''}/>
      <div>${t.text}</div>
    </div>`).join('');
  byId('todoList').innerHTML = list || '<div class="muted">No tasks found.</div>';
  [...byId('todoList').querySelectorAll('input[type="checkbox"]')].forEach(cb=>{
    cb.addEventListener('change', async (e)=>{
      const ix = Number(e.target.getAttribute('data-ix'));
      await db.ref(`rooms/${room}/users/${uid}/tasks/${ix}/done`).set(e.target.checked);
      refreshActive();
    });
  });

  await renderPlayerVoting(room, uid, state);
}
byId('refreshActiveBtn').addEventListener('click', refreshActive);

byId('saveNotesBtn').addEventListener('click', ()=>{
  const {room,name} = loadLocalIdentity();
  if (!room || !name){ alert('Join first.'); return; }
  const key = `mb_notes_${room}_${name}`;
  localStorage.setItem(key, byId('notesBox').value);
  alert('Notes saved.');
});

/* Countdown pill */
let countdownTimer=null;
function updateCountdownPill(endsAt){
  if (countdownTimer){ clearInterval(countdownTimer); countdownTimer=null; }
  const pill = byId('voteCountdownPill');
  if (!endsAt){ pill.textContent = '‚è≥ ‚Äî'; return; }
  function tick(){
    const ms = Math.max(0, endsAt - Date.now());
    const m = Math.floor(ms/60000), s = Math.floor((ms%60000)/1000).toString().padStart(2,'0');
    pill.textContent = `‚è≥ ${m}:${s}`;
    if (ms<=0 && countdownTimer){ clearInterval(countdownTimer); countdownTimer=null; }
  }
  tick();
  countdownTimer = setInterval(tick, 1000);
}

/* Player voting UI */
async function renderPlayerVoting(room, uid, state){
  const help = byId('voteHelp'), list = byId('candidateList'), tallyBox = byId('tallyBox');
  const btn = byId('castVoteBtn');
  const voting = state.voting || {open:false,closed:false};
  updateCountdownPill(voting.endsAt);
  if (!voting.open && !voting.closed){
    help.textContent = 'Waiting for Admin to open voting‚Ä¶';
    list.innerHTML = ''; tallyBox.innerHTML = ''; btn.disabled = true; return;
  }
  const [usersSnap, charsSnap] = await Promise.all([
    db.ref(`rooms/${room}/users`).get(),
    db.ref(`rooms/${room}/characters`).get()
  ]);
  const users = usersSnap.exists() ? usersSnap.val() : {};
  const chars = charsSnap.exists() ? charsSnap.val() : {};
  const candidates = voting.candidates || {};
  const votes = voting.votes || {};
  const items = Object.keys(candidates);
  const display = items.map(k=>{
    const u = users[k]; const charName = u && u.charId && chars[u.charId] ? chars[u.charId].name : '';
    const dead = u?.dead || (u?.charId && chars[u.charId]?.dead);
    return {key:k, label: u ? `${u.name}${charName? ' ‚Äî '+charName:''}${dead?' (dead)':''}` : k, dead: !!dead};
  });
  const myVote = votes[uid] || '';

  if (voting.open){
    help.textContent = 'Voting is OPEN. Choose one candidate:';
    list.innerHTML = display.map(d=>`
      <label class="vote-item">
        <input type="radio" name="voteChoice" value="${d.key}" ${myVote===d.key?'checked':''} ${d.dead?'disabled':''}/>
        <div>${d.label}</div>
      </label>
    `).join('') || '<div class="muted">No candidates yet.</div>';
    btn.disabled = false;
    tallyBox.innerHTML = '<span class="muted">Tally will appear when voting closes.</span>';
  }else{
    help.textContent = 'Voting is CLOSED. Final tally:';
    list.innerHTML = display.map(d=>`<div class="vote-item"><div>${d.label}</div></div>`).join('') || '<div class="muted">No candidates.</div>';
    btn.disabled = true;
    // compute tally
    const tally = {};
    Object.entries(votes).forEach(([voter, choice])=>{
      // count only votes from alive players
      const u = users[voter]; const alive = u && !u.dead && !(u.charId && chars[u.charId]?.dead);
      if (alive) tally[choice] = (tally[choice]||0)+1;
    });
    const tallyLines = display.map(d=>`‚Ä¢ ${d.label}: <b class="tally">${tally[d.key]||0}</b>`).join('<br>');
    tallyBox.innerHTML = tallyLines || 'No votes.';
  }
}
byId('castVoteBtn').addEventListener('click', async ()=>{
  const {room,name} = loadLocalIdentity();
  if (!room || !name) return;
  const uid = getUid(room,name);
  const state = await getRoomState(room);
  if (!state.voting?.open){ alert('Voting is not open.'); return; }
  const choice = document.querySelector('input[name="voteChoice"]:checked');
  if (!choice){ alert('Pick a candidate.'); return; }
  await db.ref(`rooms/${room}/state/voting/votes/${uid}`).set(choice.value);
  alert('Vote recorded.');
  refreshActive();
});

/* Clues (player) */
async function renderClues(){
  const room = localStorage.getItem('mb_room') || (byId('joinRoom').value||'').trim().toUpperCase();
  const list = byId('clueList');
  if (!room){ list.innerHTML = '<div class="muted">Join a room first.</div>'; return; }
  const snap = await db.ref(`rooms/${room}/clues`).get();
  if (!snap.exists()){ list.innerHTML = '<div class="muted">No clues seeded.</div>'; return; }
  const clues = Object.entries(snap.val()).filter(([id,c])=>c.revealed);
  if (!clues.length){ list.innerHTML = '<div class="muted">No clues revealed yet.</div>'; return; }
  list.innerHTML = clues.map(([id,c])=>`
    <article class="parchment">
      <div class="tag">Clue ${id}</div>
      <h4>${c.title}</h4>
      <div>${c.body}</div>
    </article>
  `).join('');
}
byId('refreshCluesBtn').addEventListener('click', renderClues);
document.getElementById('tab-clues').addEventListener('click', renderClues);

/* Admin */
let ADMIN_OK = false;
async function adminAuth(){
  const room = (byId('adminRoom').value||'').trim().toUpperCase();
  const adminPass = (byId('adminPass').value||'').trim();
  const out = byId('adminAuthStatus');
  try{
    const snap = await db.ref(`rooms/${room}/adminHash`).get();
    if (!snap.exists()) throw new Error('Room not found');
    const ok = (await hashSHA256(adminPass)) === snap.val();
    if (!ok) throw new Error('Incorrect admin password');
    ADMIN_OK = true;
    localStorage.setItem('mb_room_admin', room);
    localStorage.setItem('mb_pass_admin_ok', '1');
    out.innerHTML = `<span class="badge success">Admin unlocked</span>`;
    showAdminTab(true);
    await updateRoundAndVotingDisplays();
    await refreshPlayerDropdowns();
    await refreshCandidateSelectors();
    await renderAdminTally();
  }catch(e){
    ADMIN_OK = false;
    out.innerHTML = `<span class="badge danger">Auth failed</span> ${e.message}`;
  }
}
byId('adminAuthBtn').addEventListener('click', adminAuth);
function currentAdminRoom(){ return (byId('adminRoom').value||localStorage.getItem('mb_room_admin')||'').toUpperCase(); }

function renderLists(data){
  const chars = data||{};
  const entries = Object.entries(chars);
  const un = entries.filter(([id,c])=>!c.claimedBy).map(([id,c])=>`‚Ä¢ ${c.name}${c.dead?' (dead)':''}`).join("<br>") || '‚Äî';
  const cl = entries.filter(([id,c])=>c.claimedBy).map(([id,c])=>`‚Ä¢ <b>${c.name}</b> <span class="muted">‚Üí ${c.claimedBy}${c.dead?' (dead)':''}</span>`).join("<br>") || '‚Äî';
  byId('unclaimedBox').innerHTML = un;
  byId('claimedBox').innerHTML = cl;
}

let liveOff = null;
byId('loadRoomBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK){ byId('adminAuthStatus').innerHTML=`<span class="badge danger">Unlock Admin first</span>`; return; }
  const room = currentAdminRoom();
  const snap = await db.ref(`rooms/${room}/characters`).get();
  if (!snap.exists()){ byId('adminAuthStatus').innerHTML=`<span class="badge danger">Room not found</span>`; return; }
  renderLists(snap.val());
  await refreshPlayerDropdowns();
  await refreshCandidateSelectors();
  await renderAdminTally();
});

byId('watchRoomBtn').addEventListener('click', ()=>{
  if (!ADMIN_OK){ byId('adminAuthStatus').innerHTML=`<span class="badge danger">Unlock Admin first</span>`; return; }
  const room = currentAdminRoom();
  if (liveOff) { liveOff(); liveOff=null; }
  const ref = db.ref(`rooms/${room}/characters`);
  const cb = ref.on('value', async snap=> {
    renderLists(snap.val()||{});
    await refreshPlayerDropdowns();
    await refreshCandidateSelectors();
    await renderAdminTally();
  });
  liveOff = ()=> ref.off('value', cb);
  byId('adminAuthStatus').innerHTML = `<span class="badge">Watching live‚Ä¶</span>`;
});

async function refreshPlayerDropdowns(){
  const room = currentAdminRoom();
  const usersSnap = await db.ref(`rooms/${room}/users`).get();
  const sel = byId('playerSelect');
  const candSel = byId('candidatePlayerSelect');
  const deadSel = byId('deadToggleSelect');
  sel.innerHTML = '<option value="">‚Äî select player ‚Äî</option>';
  candSel.innerHTML = '<option value="">‚Äî add candidate (claimed players) ‚Äî</option>';
  deadSel.innerHTML = '<option value="">‚Äî select claimed player ‚Äî</option>';
  if (!usersSnap.exists()) return;
  const users = usersSnap.val();
  for (const [uid,u] of Object.entries(users)){
    const opt = document.createElement('option'); opt.value = uid; opt.textContent = u.name;
    sel.appendChild(opt);
    const opt2 = document.createElement('option'); opt2.value = uid; opt2.textContent = u.name;
    candSel.appendChild(opt2);
    const opt3 = document.createElement('option'); opt3.value = uid; opt3.textContent = `${u.name}${u.dead?' (dead)':''}`;
    deadSel.appendChild(opt3);
  }
}
document.getElementById('tab-admin').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  await updateRoundAndVotingDisplays();
  await refreshPlayerDropdowns();
  await refreshCandidateSelectors();
  await renderAdminTally();
});

/* Assign roles */
byId('assignSpecialBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK){ byId('specialStatus').innerHTML=`<span class="badge danger">Unlock Admin</span>`; return; }
  const room = currentAdminRoom();
  const uid = byId('playerSelect').value;
  const role = byId('specialSelect').value || null;
  if (!uid){ byId('specialStatus').innerHTML=`<span class="badge danger">Pick a player</span>`; return; }
  await db.ref(`rooms/${room}/users/${uid}/specialRole`).set(role);
  byId('specialStatus').innerHTML = `<span class="badge success">Saved</span>`;
  await checkWinConditions(room);
});

/* Mark Dead/Alive */
byId('markDeadBtn').addEventListener('click', ()=> toggleDead(true));
byId('markAliveBtn').addEventListener('click', ()=> toggleDead(false));

async function toggleDead(dead){
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  const uid = byId('deadToggleSelect').value;
  if (!uid) return;
  const uSnap = await db.ref(`rooms/${room}/users/${uid}`).get();
  if (!uSnap.exists()) return;
  const u = uSnap.val();
  await db.ref(`rooms/${room}/users/${uid}/dead`).set(dead);
  if (u.charId) await db.ref(`rooms/${room}/characters/${u.charId}/dead`).set(dead);
  await renderAdminTally();
  await updateRoundAndVotingDisplays();
  await checkWinConditions(room, dead ? `Marked ${u.name} dead.` : `Marked ${u.name} alive.`);
}

/* Round & Voting Controls (Admin) */
async function updateRoundAndVotingDisplays(){
  const room = currentAdminRoom();
  const state = await getRoomState(room);
  byId('adminRoundDisplay').value = state.round || 1;
  byId('votingStatusDisplay').value = state.voting?.open ? 'OPEN' : (state.voting?.closed ? 'CLOSED' : '‚Äî');
}

byId('nextRoundBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  const state = await getRoomState(room);
  const next = (state.round||1) + 1;
  await db.ref(`rooms/${room}/state`).set({
    round: next,
    voting: { open:false, closed:false, candidates:null, votes:null, endsAt:null }
  });
  await updateRoundAndVotingDisplays();
  await renderAdminTally();
  await checkWinConditions(room, `Advanced to Round ${next}.`);
});

/* Voting Open/Close/Clear and Timer */
byId('openVotingBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  const state = await getRoomState(room);
  await db.ref(`rooms/${room}/state/voting`).set({
    open:true, closed:false,
    candidates: state.voting?.candidates || null,
    votes: state.voting?.votes || null,
    endsAt:null
  });
  await updateRoundAndVotingDisplays(); await renderAdminTally();
});

byId('closeVotingBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  await closeVotingAndResolve(room, true);
});

byId('clearVotingBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  await db.ref(`rooms/${room}/state/voting`).set({ open:false, closed:false, candidates:null, votes:null, endsAt:null });
  await updateRoundAndVotingDisplays(); await refreshCandidateSelectors(); await renderAdminTally();
});

byId('start5minVoteBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  const endsAt = Date.now() + 5*60*1000;
  const state = await getRoomState(room);
  await db.ref(`rooms/${room}/state/voting`).set({
    open:true, closed:false,
    candidates: state.voting?.candidates || null,
    votes: state.voting?.votes || null,
    endsAt
  });
  await updateRoundAndVotingDisplays(); await renderAdminTally();
  // Local admin watcher to close automatically at expiry
  scheduleAutoClose(room, endsAt);
});

/* Candidate add/remove */
async function refreshCandidateSelectors(){
  const room = currentAdminRoom();
  const state = await getRoomState(room);
  const candidates = state.voting?.candidates || {};
  const usersSnap = await db.ref(`rooms/${room}/users`).get();
  const charsSnap = await db.ref(`rooms/${room}/characters`).get();
  const users = usersSnap.exists()? usersSnap.val() : {};
  const chars = charsSnap.exists()? charsSnap.val() : {};
  const removeSel = byId('removeCandidateSelect');
  removeSel.innerHTML = '<option value="">‚Äî remove candidate ‚Äî</option>';
  for (const key of Object.keys(candidates||{})){
    const u = users[key]; const charName = u && u.charId && chars[u.charId] ? chars[u.charId].name : '';
    const opt = document.createElement('option');
    opt.value = key; opt.textContent = u ? `${u.name}${charName? ' ‚Äî '+charName:''}` : key;
    removeSel.appendChild(opt);
  }
}
byId('addCandidateBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  const uid = byId('candidatePlayerSelect').value;
  if (!uid) return;
  await db.ref(`rooms/${room}/state/voting/candidates/${uid}`).set(true);
  await refreshCandidateSelectors(); await renderAdminTally();
});
byId('removeCandidateBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  const uid = byId('removeCandidateSelect').value;
  if (!uid) return;
  await db.ref(`rooms/${room}/state/voting/candidates/${uid}`).remove();
  // clear votes for removed candidate
  const votesSnap = await db.ref(`rooms/${room}/state/voting/votes`).get();
  if (votesSnap.exists()){
    const votes = votesSnap.val();
    for (const [voter, choice] of Object.entries(votes)){
      if (choice === uid) await db.ref(`rooms/${room}/state/voting/votes/${voter}`).remove();
    }
  }
  await refreshCandidateSelectors(); await renderAdminTally();
});

/* Admin Tally */
async function renderAdminTally(){
  const room = currentAdminRoom();
  const state = await getRoomState(room);
  const voting = state.voting || {};
  const [usersSnap, charsSnap] = await Promise.all([
    db.ref(`rooms/${room}/users`).get(),
    db.ref(`rooms/${room}/characters`).get()
  ]);
  const users = usersSnap.exists()? usersSnap.val(): {};
  const chars = charsSnap.exists()? charsSnap.val(): {};
  const candidates = voting.candidates || {};
  const votes = voting.votes || {};
  const display = Object.keys(candidates).map(k=>{
    const u = users[k]; const charName = u && u.charId && chars[u.charId] ? chars[u.charId].name : '';
    return {key:k, label: u ? `${u.name}${charName? ' ‚Äî '+charName:''}` : k};
  });
  const alive = Object.entries(users).filter(([uid,u])=>{
    const dead = u.dead || (u.charId && chars[u.charId]?.dead);
    return !dead;
  }).length;
  const tally = {};
  Object.entries(votes).forEach(([voter, choice])=>{
    const u = users[voter]; const aliveVoter = u && !u.dead && !(u.charId && chars[u.charId]?.dead);
    if (aliveVoter) tally[choice] = (tally[choice]||0)+1;
  });
  const lines = display.map(d=>`‚Ä¢ ${d.label}: <b class="tally">${tally[d.key]||0}</b>`).join('<br>');
  byId('adminTallyBox').innerHTML = (alive? `<div class="muted">Alive voters: ${alive}</div>` : '') + (lines || 'No votes yet.');
}

/* Auto close */
function scheduleAutoClose(room, endsAt){
  const ms = Math.max(0, endsAt - Date.now());
  setTimeout(async ()=>{
    const state = await getRoomState(room);
    if (state.voting?.open && state.voting.endsAt && Date.now() >= state.voting.endsAt){
      await closeVotingAndResolve(room, false);
    }
  }, ms + 1000);
}

/* Close vote, resolve, eliminate (if ‚â•50% of alive), popup */
async function closeVotingAndResolve(room, manual){
  const state = await getRoomState(room);
  const voting = state.voting || {};
  if (!voting.open) return;
  // close
  await db.ref(`rooms/${room}/state/voting/open`).set(false);
  await db.ref(`rooms/${room}/state/voting/closed`).set(true);

  // compute results
  const [usersSnap, charsSnap] = await Promise.all([
    db.ref(`rooms/${room}/users`).get(),
    db.ref(`rooms/${room}/characters`).get()
  ]);
  const users = usersSnap.exists()? usersSnap.val(): {};
  const chars = charsSnap.exists()? charsSnap.val(): {};
  const votes = voting.votes || {};
  const aliveUsers = Object.entries(users).filter(([uid,u])=> !(u.dead || (u.charId && chars[u.charId]?.dead)));
  const aliveCount = aliveUsers.length;

  const tally = {};
  for (const [voter, choice] of Object.entries(votes)){
    const u = users[voter];
    const aliveVoter = u && !u.dead && !(u.charId && chars[u.charId]?.dead);
    if (aliveVoter) tally[choice] = (tally[choice]||0)+1;
  }
  // find top
  let bestKey = null, bestCount = -1;
  Object.entries(tally).forEach(([k,c])=>{ if (c>bestCount){ bestKey=k; bestCount=c; }});
  const needed = Math.ceil(aliveCount * 0.5); // ‚â•50% threshold
  let resultHtml = `<div>Alive voters: <b>${aliveCount}</b> ‚Ä¢ Threshold to eliminate: <b>${needed}</b></div><br>`;
  for (const [k,c] of Object.entries(tally)){
    const u = users[k];
    const label = u ? u.name : k;
    resultHtml += `‚Ä¢ ${label}: <b class="tally">${c}</b><br>`;
  }
  if (bestKey && bestCount >= needed){
    // eliminate
    const u = users[bestKey];
    if (u){
      await db.ref(`rooms/${room}/users/${bestKey}/dead`).set(true);
      if (u.charId) await db.ref(`rooms/${room}/characters/${u.charId}/dead`).set(true);
      resultHtml += `<br><b>Eliminated:</b> ${u.name} (by vote)`;
    }
  }else{
    resultHtml += `<br><b>No elimination.</b>`;
  }

  popup('Mob Justice ‚Äî Results', resultHtml);
  await renderAdminTally();
  await checkWinConditions(room);
}

/* Win conditions */
async function checkWinConditions(room, extraMsg){
  const [usersSnap, charsSnap, stateSnap] = await Promise.all([
    db.ref(`rooms/${room}/users`).get(),
    db.ref(`rooms/${room}/characters`).get(),
    db.ref(`rooms/${room}/state`).get()
  ]);
  if (!usersSnap.exists()) return;
  const users = usersSnap.val();
  const chars = charsSnap.exists()? charsSnap.val(): {};
  const state = stateSnap.exists()? stateSnap.val(): {round:1};

  const aliveUsers = Object.values(users).filter(u=> !(u.dead || (u.charId && chars[u.charId]?.dead)));
  const aliveVamps = aliveUsers.filter(u=> ['Elder Vampire','Lesser Vampire'].includes(u.specialRole));
  const aliveNonVamps = aliveUsers.filter(u=> !['Elder Vampire','Lesser Vampire'].includes(u.specialRole));

  // Village win: all vampires dead
  if (aliveVamps.length === 0){
    popup('Village Victory', `<div>The Elder and Lesser vampires are dead. The village prevails!${extraMsg? `<br><br><i>${extraMsg}</i>`:''}</div>`);
    return;
  }
  // Vampire win: parity or rounds > 4 with any vampire alive
  if (aliveVamps.length >= aliveNonVamps.length || (state.round>4 && aliveVamps.length>0)){
    popup('Vampires Triumph', `<div>The night belongs to fangs and shadow.${extraMsg? `<br><br><i>${extraMsg}</i>`:''}</div>`);
  }
}

/* CSV Import (Admin) */
function parseCSV(text){
  // Minimal CSV parser supporting quotes and commas
  const rows=[]; let cur=''; let row=[]; let inq=false;
  for (let i=0;i<text.length;i++){
    const ch=text[i], nxt=text[i+1];
    if (ch==='\"'){
      if (inq && nxt==='\"'){ cur+='\"'; i++; }
      else inq=!inq;
    }else if (ch===',' && !inq){
      row.push(cur); cur='';
    }else if ((ch==='\n' || ch==='\r') && !inq){
      if (cur.length||row.length){ row.push(cur); rows.push(row); cur=''; row=[]; }
      if (ch==='\r' && nxt==='\n') i++;
    }else cur+=ch;
  }
  if (cur.length||row.length) { row.push(cur); rows.push(row); }
  return rows;
}

byId('importCharsBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  const file = byId('csvChars').files[0];
  if (!file){ byId('csvStatus').textContent='Select a characters CSV.'; return; }
  const txt = await file.text();
  const rows = parseCSV(txt).filter(r=>r.length>=1);
  const chars={}; let i=0;
  for (const r of rows){
    const name=(r[0]||'').trim(); if (!name) continue;
    const desc=(r[1]||'').trim()||null;
    const id='c_'+(i++).toString().padStart(3,'0');
    chars[id]={name, desc, claimedBy:null, claimedAt:null, dead:false};
  }
  if (!Object.keys(chars).length){ byId('csvStatus').textContent='No valid rows found.'; return; }
  await db.ref(`rooms/${room}/characters`).set(chars);
  byId('csvStatus').textContent='Characters imported.';
  await renderAdminTally(); await refreshPlayerDropdowns();
});

byId('useDefaultCharsBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  const chars={}; CHARACTERS.forEach((line,i)=>{
    const id='c_'+i.toString().padStart(3,'0');
    chars[id]={name:line, desc:null, claimedBy:null, claimedAt:null, dead:false};
  });
  await db.ref(`rooms/${room}/characters`).set(chars);
  byId('csvStatus').textContent='Default characters loaded.';
  await renderAdminTally(); await refreshPlayerDropdowns();
});

byId('importCluesBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  const file = byId('csvClues').files[0];
  if (!file){ byId('csvStatus').textContent='Select a clues CSV.'; return; }
  const txt = await file.text();
  const rows = parseCSV(txt).filter(r=>r.length>=3);
  const clues={};
  for (const r of rows){
    const id=(r[0]||'').trim(); const title=(r[1]||'').trim(); const body=(r[2]||'').trim();
    if (!id || !title || !body) continue;
    clues[id]={title, body, revealed:false};
  }
  if (!Object.keys(clues).length){ byId('csvStatus').textContent='No valid clue rows found.'; return; }
  await db.ref(`rooms/${room}/clues`).set(clues);
  byId('csvStatus').textContent='Clues imported.';
});

byId('useDefaultCluesBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  const clues={}; DEFAULT_CLUES.forEach(c=> clues[c.id]={title:c.title, body:c.body, revealed:false});
  await db.ref(`rooms/${room}/clues`).set(clues);
  byId('csvStatus').textContent='Default clues loaded.';
});

/* Clues Admin */
let workingClues = [];
byId('loadCluesBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK){ byId('clueAdminStatus').textContent='Unlock Admin first'; return; }
  const room = currentAdminRoom();
  const snap = await db.ref(`rooms/${room}/clues`).get();
  if (!snap.exists()){
    workingClues = DEFAULT_CLUES.map(c=>({...c, revealed:false}));
  }else{
    workingClues = Object.entries(snap.val()).map(([id,c])=>({id, title:c.title, body:c.body, revealed: !!c.revealed}));
  }
  renderClueAdminList();
  byId('clueAdminStatus').textContent = 'Loaded';
});
function renderClueAdminList(){
  const box = byId('clueAdminList');
  box.innerHTML = workingClues.map((c,i)=>`
    <div class="parchment">
      <div class="row" style="justify-content:space-between">
        <div class="tag">Clue ${c.id}</div>
        <label class="row" style="gap:6px"><input type="checkbox" data-ix="${i}" ${c.revealed?'checked':''}/> Reveal</label>
      </div>
      <h4>${c.title}</h4>
      <div>${c.body}</div>
    </div>
  `).join('');
  [...box.querySelectorAll('input[type="checkbox"]')].forEach(cb=>{
    cb.addEventListener('change',(e)=>{
      const ix = Number(e.target.getAttribute('data-ix'));
      workingClues[ix].revealed = e.target.checked;
    });
  });
}
byId('publishCluesBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK){ byId('clueAdminStatus').textContent='Unlock Admin first'; return; }
  const room = currentAdminRoom();
  const updates = {}; workingClues.forEach(c=>{ updates[c.id] = {title:c.title, body:c.body, revealed: !!c.revealed}; });
  await db.ref(`rooms/${room}/clues`).set(updates);
  byId('clueAdminStatus').textContent = 'Published';
});

/* UI collapse for assigned players */
function collapseToActiveOnly(){
  ['tab-host','tab-join','tab-clues','tab-admin'].forEach(id=>{
    const el = document.getElementById(id); if (el) el.style.display = 'none';
  });
  document.getElementById('tab-active').setAttribute('aria-selected','true');
  document.getElementById('panel-active').hidden = false;
  ['panel-host','panel-join','panel-clues','panel-admin'].forEach(id=>{
    const el = document.getElementById(id); if (el) el.hidden = true;
  });
}
function gateForAssigned(){
  const hasChar = !!localStorage.getItem('mb_charId');
  if (hasChar) collapseToActiveOnly();
}

/* Prefill and init */
(function(){
  const r = getCookie('mb_room'); const n = getCookie('mb_name');
  if (r) byId('joinRoom').value = r;
  if (n) byId('realName').value = n;
})();
document.addEventListener('DOMContentLoaded', ()=>{
  gateForAssigned();
  refreshActive();
});
</script>
</body>
</html>
