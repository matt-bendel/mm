<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Moonlit Bandanas - Join</title>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Inter:wght@400;600&family=Crimson+Text:wght@400;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="./style.css">
</head>
<body>
<header>
  <div class="title">Moonlit Bandanas</div>
  <div class="navlinks" id="topLinks"><a href="./create.html">Create</a> &bull; <a href="./admin.html">Admin</a></div>
</header>

<div class="wrap">
  <!-- JOIN -->
  <section id="panel-join" class="panel">
    <div class="grid">
      <div><label>Room Code</label><input id="joinRoom" placeholder="Enter room code exactly" /></div>
      <div><label>Room Password</label><input id="joinPass" type="password" placeholder="Enter the room password" /></div>
      <div><label>Your Real Name</label><input id="realName" placeholder="e.g., Alex Johnson" /></div>
      <div class="row">
        <button class="btn" id="assignBtn">Get My Character</button>
        <button class="btn secondary" id="revealMineBtn">Reveal Mine Again</button>
      </div>
      <div id="assignStatus" class="muted"></div>
    </div>
  </section>

  <!-- ACTIVE -->
  <section id="panel-active" class="panel" hidden>
    <div class="grid">
      <div class="row" style="justify-content:space-between">
        <div class="row" style="gap:12px">
          <span class="pill" id="roundPill">Round: -</span>
          <span class="pill" id="voteStatusPill">Vote: -</span>
          <span class="pill" id="voteCountdownPill">Timer: --</span>
        </div>
      </div>

      <div class="divider"></div>

      <div class="card" id="charSummaryBox">
        <h3 class="kicker" id="charHeader">Your Character</h3>
        <div id="charSummaryText" class="muted">-</div>
      </div>

      <div class="tab-shell">
        <div class="tab-bar" id="playerTabBar">
          <button class="tab-btn active" data-target="tab-objectives">Objectives & Notes</button>
          <button class="tab-btn" data-target="tab-clues">Clues</button>
          <button class="tab-btn" data-target="tab-justice">Mob Justice</button>
          <button class="tab-btn" id="roleTabBtn" data-target="tab-role" hidden>Role</button>
        </div>
        <div class="tab-panels">
          <section id="tab-objectives" class="tab-panel active">
            <div id="waitingState" class="card">
              <h3 class="kicker">Waiting for Host to Start</h3>
              <div class="muted">You'll see objectives, notes, and Mob Justice once the game begins.</div>
            </div>
            <div id="liveObjectiveBlock" hidden>
              <div class="card">
                <h3 class="kicker">Your Objectives</h3>
                <div id="todoList" class="muted">-</div>
              </div>
              <div class="card" id="elderTargetsBox" hidden>
                <h3 class="kicker">Marked Targets</h3>
                <div id="elderTargetsList" class="muted">No targets assigned.</div>
              </div>
              <div class="card">
                <h3 class="kicker">Notes (private)</h3>
                <textarea id="notesBox" placeholder="Jot suspects, alibis, or reminders (saved on this device)"></textarea>
                <div class="row" style="margin-top:8px">
                  <button class="btn secondary" id="saveNotesBtn">Save Notes</button>
                  <span class="muted">Notes are not uploaded.</span>
                </div>
              </div>
            </div>
          </section>
          <section id="tab-clues" class="tab-panel">
            <div class="card">
              <h3 class="kicker">Revealed Clues</h3>
              <div id="cluesList" class="grid" style="gap:14px"></div>
            </div>
          </section>
          <section id="tab-justice" class="tab-panel">
            <div class="card">
              <h3 class="kicker">Mob Justice</h3>
              <div id="voteBlock">
                <div class="muted" id="voteHelp">Waiting for Admin to open voting...</div>
                <div id="candidateList" class="vote-list" style="margin-top:8px"></div>
                <div class="row" style="margin-top:10px">
                  <button class="btn" id="castVoteBtn">Cast / Update Vote</button>
                  <span class="muted">One vote per round; you can change it until voting closes.</span>
                </div>
                <div class="divider"></div>
                <div id="tallyBox" class="muted"></div>
              </div>
            </div>
          </section>
          <section id="tab-role" class="tab-panel">
            <div class="card">
              <h3 class="kicker">Role Details</h3>
              <div id="roleDetailsBox" class="muted">No special role assigned.</div>
            </div>
          </section>
        </div>
      </div>

    </div>
  </section>
</div>

<dialog id="resultModal">
  <div class="modal-head" id="modalTitle">Result</div>
  <div class="modal-body" id="modalBody"></div>
  <div class="modal-actions"><button class="btn secondary" id="closeModalBtn">Close</button></div>
</dialog>

<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-database-compat.js"></script>
<script src="./app.js"></script>
<script>
MB.initFirebase();
const db = MB.getDB();
const {$, setCookie, getCookie, uid, verifyRoomPassword, claimCharacter,
       renderRoleDetails, bindModal, storage, elderTargetsArray, userIsDead} = MB;
const store = storage || {get:()=>"", set:()=>{}, remove:()=>{}, clear:()=>{}};
const {popup} = bindModal('closeModalBtn');

// Helper: base character name (strip biography regardless of dash variant)
function baseCharName(str){
  const val = (str||'').trim();
  const separators = [' \u2014 ', ' - ', ' \u2013 '];
  for (const sep of separators){
    const ix = val.indexOf(sep);
    if (ix !== -1) return val.slice(0, ix).trim();
  }
  return val;
}

// Prefill from cookies
(function(){
  const r = getCookie('mb_room'), n = getCookie('mb_name');
  if (r) $('joinRoom').value = r;
  if (n) $('realName').value = n;
})();

function saveLocal(room,name,charId,charName){
  store.set('mb_room', room);
  store.set('mb_name', name);
  store.set('mb_charId', charId);
  store.set('mb_charName', charName);
  setCookie('mb_room', room, 30);
  setCookie('mb_name', name, 30);
}

function hideTopLinksAfterJoin(joined){
  const nav = $('topLinks');
  if (nav){
    nav.hidden = !!joined;
    nav.style.display = joined ? 'none' : '';
  }
}

const tabState = { current: 'tab-objectives' };
const tabLock = { target: null };
const playerTabBar = $('playerTabBar');
const tabButtons = playerTabBar ? [...playerTabBar.querySelectorAll('.tab-btn')] : [];
const tabPanels = ()=> [...document.querySelectorAll('.tab-panel')];
function applyTabLockStyles(){
  tabButtons.forEach(btn=>{
    const target = btn.getAttribute('data-target');
    const locked = !!(tabLock.target && target !== tabLock.target);
    btn.disabled = locked;
    btn.classList.toggle('locked', locked);
  });
}
function activateTab(targetId){
  if (tabLock.target && targetId !== tabLock.target){
    targetId = tabLock.target;
  }
  tabState.current = targetId;
  tabButtons.forEach(btn=>{
    const target = btn.getAttribute('data-target');
    const active = target === targetId;
    btn.classList.toggle('active', active);
    if (active) btn.setAttribute('aria-selected','true');
    else btn.removeAttribute('aria-selected');
  });
  tabPanels().forEach(panel=>{
    const active = panel.id === targetId;
    panel.classList.toggle('active', active);
    panel.hidden = !active;
  });
  applyTabLockStyles();
}
function setTabLock(targetId){
  if (tabLock.target === targetId) return;
  tabLock.target = targetId;
  applyTabLockStyles();
  if (tabLock.target){
    activateTab(tabLock.target);
  }
}
if (playerTabBar){
  playerTabBar.addEventListener('click', (evt)=>{
    const btn = evt.target.closest('.tab-btn');
    if (!btn || btn.disabled) return;
    const target = btn.getAttribute('data-target');
    if (target) activateTab(target);
  });
  activateTab(tabState.current);
}else{
  applyTabLockStyles();
}

const activeSession = {
  room: '',
  name: '',
  charId: '',
  charName: '',
  uid: '',
  subscribedRoom: '',
  subscribedUid: '',
  listeners: [],
  data: { state: null, users: null, characters: null, clues: null },
  lastPopupTs: 0,
  canVote: false
};

function resetActiveData(){
  activeSession.data.state = null;
  activeSession.data.users = null;
  activeSession.data.characters = null;
  activeSession.data.clues = null;
  activeSession.lastPopupTs = 0;
}

function detachActiveListeners(){
  activeSession.listeners.forEach(({ref, handler})=> ref.off('value', handler));
  activeSession.listeners.length = 0;
  activeSession.subscribedRoom = '';
  activeSession.subscribedUid = '';
  resetActiveData();
}

function ensureActiveSubscriptions(room, uidVal){
  if (!room || !uidVal){
    detachActiveListeners();
    return;
  }
  if (activeSession.subscribedRoom === room && activeSession.subscribedUid === uidVal){
    return;
  }

  detachActiveListeners();
  activeSession.subscribedRoom = room;
  activeSession.subscribedUid = uidVal;

  const addListener = (path, key)=>{
    const ref = db.ref(path);
    const handler = snap=>{
      const val = snap.exists()? snap.val() : null;
      if (key === 'state') activeSession.data.state = val || {};
      else if (key === 'users') activeSession.data.users = val || {};
      else if (key === 'characters') activeSession.data.characters = val || {};
      else if (key === 'clues') activeSession.data.clues = val || {};
      renderActiveWithData();
    };
    ref.on('value', handler);
    activeSession.listeners.push({ref, handler});
  };

  addListener(`rooms/${room}/state`, 'state');
  addListener(`rooms/${room}/users`, 'users');
  addListener(`rooms/${room}/characters`, 'characters');
  addListener(`rooms/${room}/clues`, 'clues');
}

$('assignBtn').onclick = async ()=>{
  const room = ($('joinRoom').value||'').trim().toUpperCase();
  const pass = ($('joinPass').value||'').trim();
  const name = ($('realName').value||'').trim();
  const status = $('assignStatus');
  if (!room || !pass || !name){ status.textContent='Enter room, password, and name.'; return; }
  status.textContent='Assigning...';
  try{
    const pick = await claimCharacter(room, pass, name);
    saveLocal(room, name, pick.id, pick.name);
    status.textContent='Assigned.';
    $('panel-join').hidden = true;
    $('panel-active').hidden = false;
    hideTopLinksAfterJoin(true);
    await refreshActive();
  }catch(e){ status.textContent = 'Error: '+e.message; }
};

$('revealMineBtn').onclick = async ()=>{
  const room = ($('joinRoom').value||'').trim().toUpperCase();
  const pass = ($('joinPass').value||'').trim();
  const name = ($('realName').value||'').trim();
  const status = $('assignStatus');
  if (!room || !pass || !name){ status.textContent='Enter room, password, and name.'; return; }
  try{
    const ok = await verifyRoomPassword(room, pass);
    if (!ok) throw new Error('Incorrect password');
    const myUid = uid(room, name);
    const uSnap = await db.ref(`rooms/${room}/users/${myUid}`).get();
    if (!uSnap.exists()){ status.textContent='No prior assignment.'; return; }
    const {charId} = uSnap.val();
    const rSnap = await db.ref(`rooms/${room}/characters/${charId}`).get();
    const charName = rSnap.exists()? rSnap.val().name : '(unknown)';
    saveLocal(room, name, charId, charName);
    $('panel-join').hidden = true;
    $('panel-active').hidden = false;
    hideTopLinksAfterJoin(true);
    await refreshActive();
  }catch(e){ status.textContent = 'Error: '+e.message; }
};

$('saveNotesBtn').onclick = ()=>{
  const room = store.get('mb_room'); const name = store.get('mb_name');
  if (!room || !name){ alert('Join first.'); return; }
  store.set(`mb_notes_${room}_${name}`, $('notesBox').value);
  alert('Notes saved.');
};

async function refreshActive(){
  const room = store.get('mb_room') || '';
  const name = store.get('mb_name') || '';
  const charId = store.get('mb_charId') || '';
  const charName = store.get('mb_charName') || '';

  const joined = !!charId;
  hideTopLinksAfterJoin(joined);

  activeSession.room = room;
  activeSession.name = name;
  activeSession.charId = charId;
  activeSession.charName = charName;
  activeSession.uid = joined && room && name ? uid(room, name) : '';
  activeSession.lastPopupTs = joined && room ? Number(store.get(`mb_last_popup_${room}`)||0) : 0;
  activeSession.canVote = false;

  if (!joined){
    detachActiveListeners();
    $('panel-join').hidden = false;
    $('panel-active').hidden = true;
    tabState.current = 'tab-objectives';
    setTabLock(null);
    activateTab(tabState.current);
    return;
  }

  $('panel-join').hidden = true;
  $('panel-active').hidden = false;
  activateTab(tabState.current);

  ensureActiveSubscriptions(room, activeSession.uid);
  await renderActiveWithData();
}

async function renderActiveWithData(){
  const {room, name, uid: myUid, charId, charName} = activeSession;
  if (!room || !name || !myUid) return;

  const state = activeSession.data.state || {};
  const voting = state.voting || {};
  const users = activeSession.data.users || {};
  const chars = activeSession.data.characters || {};
  const clues = activeSession.data.clues || {};
  const me = users ? users[myUid] : null;
  const charRec = (me && me.charId && chars[me.charId]) || (charId && chars[charId]) || null;
  const charLine = baseCharName(charRec ? charRec.name : (charName||'-'));
  const charDetails = [];
  if (charRec){
    if (charRec.ties) charDetails.push(`<div><b>Ties:</b> ${charRec.ties}</div>`);
    if (charRec.quirk) charDetails.push(`<div><b>Quirk:</b> ${charRec.quirk}</div>`);
    if (charRec.secret) charDetails.push(`<div><b>Secret:</b> ${charRec.secret}</div>`);
    if (!charDetails.length && (charRec.bio || charRec.desc)){
      charDetails.push(`<div class="muted">${charRec.bio || charRec.desc}</div>`);
    }
  }
  const detailsBlock = charDetails.length ? `<div class="char-details">${charDetails.join('')}</div>` : '';

  const popupInfo = state.lastPopup;
  if (popupInfo?.ts && popupInfo.ts !== activeSession.lastPopupTs){
    popup(popupInfo.title || 'Notice', popupInfo.html || popupInfo.body || '');
    activeSession.lastPopupTs = popupInfo.ts;
    if (room) store.set(`mb_last_popup_${room}`, String(popupInfo.ts));
  }

  const currentRound = (typeof state.round === 'number') ? state.round : (state.round || 1);
  $('roundPill').textContent = `Round: ${currentRound}`;
  $('voteStatusPill').textContent = `Vote: ${voting.open ? 'OPEN' : (voting.closed ? 'CLOSED' : '-')}`;
  MB.updateCountdownPill($('voteCountdownPill'), voting.endsAt);

  const roleTabBtn = $('roleTabBtn');
  const roleDetailsBox = $('roleDetailsBox');
  const waitingCard = $('waitingState');
  const waitingBody = waitingCard ? waitingCard.querySelector('.muted') : null;
  const liveObjectiveBlock = $('liveObjectiveBlock');
  const notesBox = $('notesBox');
  const notesCard = notesBox ? notesBox.closest('.card') : null;
  const elderTargetsBox = $('elderTargetsBox');
  const elderTargetsList = $('elderTargetsList');
  const tabShell = document.querySelector('.tab-shell');
  const todoListEl = $('todoList');
  const objectiveCard = todoListEl ? todoListEl.closest('.card') : null;

  const isDead = me ? userIsDead(me, chars) : false;
  $('charHeader').textContent = me ? `Your Character${isDead ? ' (Dead)' : ''}` : 'Your Character';
  const nameMarkup = `<b>${isDead ? `<span class="dead-name">${charLine}</span>` : charLine}</b>`;
  const summaryInner = me ? `<div>${nameMarkup}</div>${detailsBlock}`
                          : `<div><b>${charLine}</b></div><div class="muted">Waiting for assignment sync...</div>`;
  $('charSummaryText').innerHTML = summaryInner;

  if (!me){
    setTabLock(null);
    if (roleDetailsBox) roleDetailsBox.innerHTML = 'No special role assigned.';
    if (roleTabBtn){
      roleTabBtn.hidden = true;
      if (tabState.current === 'tab-role') activateTab('tab-objectives');
    }
    if (waitingCard){
      waitingCard.hidden = false;
      if (waitingBody) waitingBody.textContent = "Join a room to see live updates.";
    }
    if (liveObjectiveBlock) liveObjectiveBlock.hidden = true;
    if (elderTargetsBox) elderTargetsBox.hidden = true;
    if (tabShell) tabShell.hidden = true;
    if (notesCard) notesCard.hidden = true;
    renderClues(clues);
    activeSession.canVote = false;
    return;
  }

  const roleMarkup = MB.renderRoleDetails(me, users, chars, state);
  if (roleDetailsBox){
    roleDetailsBox.innerHTML = roleMarkup || 'No special role assigned.';
    roleDetailsBox.classList.toggle('muted', !roleMarkup);
  }
  if (roleTabBtn){
    roleTabBtn.hidden = !roleMarkup;
    if (roleTabBtn.hidden && tabState.current === 'tab-role') activateTab('tab-objectives');
  }

  if (tabShell) tabShell.hidden = false;
  renderClues(clues);

  if (isDead){
    setTabLock(null);
    activeSession.canVote = false;
    if (tabShell){
      tabShell.hidden = true;
      if (tabState.current !== 'tab-objectives') activateTab('tab-objectives');
    }
    if (waitingCard){
      waitingCard.hidden = false;
      if (waitingBody) waitingBody.textContent = 'You have been eliminated. Observe as a ghost but you may not vote or complete objectives.';
    }
    if (liveObjectiveBlock) liveObjectiveBlock.hidden = true;
    if (elderTargetsBox) elderTargetsBox.hidden = true;
    if (objectiveCard) objectiveCard.hidden = false;
    if (notesCard) notesCard.hidden = false;
    if (todoListEl) todoListEl.innerHTML = '<div class="muted">Eliminated players cannot complete objectives.</div>';
    return;
  }

  const gameStarted = !!state.gameStarted;
  if (!gameStarted){
    setTabLock(null);
    activeSession.canVote = false;
    if (waitingCard){
      waitingCard.hidden = false;
      if (waitingBody) waitingBody.textContent = "You'll see objectives, notes, and Mob Justice once the game begins.";
    }
    if (liveObjectiveBlock) liveObjectiveBlock.hidden = true;
    if (elderTargetsBox) elderTargetsBox.hidden = true;
    if (objectiveCard) objectiveCard.hidden = false;
    if (notesCard) notesCard.hidden = false;
    if (todoListEl) todoListEl.innerHTML = '<div class="muted">Objectives unlock when the host starts the round.</div>';
    renderPlayerVoting(room, myUid, state, users, chars, activeSession.canVote, me);
    return;
  }

  if (waitingCard) waitingCard.hidden = true;
  if (liveObjectiveBlock) liveObjectiveBlock.hidden = false;
  activeSession.canVote = true;
  setTabLock(voting.open ? 'tab-justice' : null);

  const isActiveElder = me.specialRole === 'Elder Vampire';
  if (objectiveCard) objectiveCard.hidden = isActiveElder;
  if (notesCard) notesCard.hidden = isActiveElder;
  if (todoListEl){
    if (isActiveElder){
      todoListEl.innerHTML = '<div class="muted">As the Elder Vampire, your focus is on the marked targets alone.</div>';
    }else{
      const toShow = Math.min(me.tasks?.length||0, state.round||1);
      const tasks = (me.tasks||[]).slice(0, toShow);
      todoListEl.innerHTML = tasks.map((t,i)=>`
        <label class="todo ${t.done?'done':''}">
          <input type="checkbox" data-ix="${i}" ${t.done?'checked':''}/>
          <span>${t.text}</span>
        </label>`).join('') || '<div class="muted">No tasks.</div>';
      [...todoListEl.querySelectorAll('input[type="checkbox"]')].forEach(cb=>{
        cb.addEventListener('change', async (e)=>{
          const ix = Number(e.target.getAttribute('data-ix'));
          await db.ref(`rooms/${room}/users/${myUid}/tasks/${ix}/done`).set(e.target.checked);
        });
      });
    }
  }

  if (notesBox) notesBox.value = store.get(`mb_notes_${room}_${name}`)||'';
  renderPlayerVoting(room, myUid, state, users, chars, activeSession.canVote, me);

  if (elderTargetsBox && elderTargetsList){
    if (me.specialRole === 'Elder Vampire'){
      const targets = elderTargetsArray(state);
      const currentRound = state.round || 1;
      const visible = targets.filter(t=> t.round <= currentRound);
      const lines = visible.map(slot=>{
        if (!slot.uid) return `<div class="muted">Round ${slot.round}: (awaiting target assignment)</div>`;
        const target = users[slot.uid];
        const dead = target ? userIsDead(target, chars) : false;
        const targetName = target ? target.name : '(unknown)';
        const charName = target && target.charId && chars[target.charId] ? baseCharName(chars[target.charId].name) : '';
        const charLabel = charName ? `${dead ? `<span class="dead-name">${charName}</span>` : charName}${dead ? ' (dead)' : ' (alive)'}` : (dead ? '(dead)' : '(alive)');
        const separator = charName ? ' - ' : ' ';
        return `<div>Round ${slot.round}: <b>${targetName}</b>${separator}${charLabel}</div>`;
      });
      elderTargetsList.innerHTML = lines.length ? lines.join('') : '<div class="muted">Targets will appear as rounds advance.</div>';
      elderTargetsBox.hidden = false;
    }else{
      elderTargetsBox.hidden = true;
    }
  }
}
function renderClues(clues){
  const box = $('cluesList');
  if (!box) return;
  box.innerHTML = '';
  const revealed = Object.entries(clues||{}).filter(([id,c])=> c && c.revealed);
  if (!revealed.length){
    box.innerHTML = '<div class="muted">No clues revealed yet.</div>';
    return;
  }
  revealed.sort((a,b)=> a[0].localeCompare(b[0])).forEach(([id,c])=>{
    const el = document.createElement('article');
    el.className = 'parchment';
    el.innerHTML = `<div class="tag">Clue ${id}</div><h4>${c.title||'(untitled)'}</h4><div>${c.body||''}</div>`;
    box.appendChild(el);
  });
}

function renderPlayerVoting(room, uidVal, state, users, chars, canVote, me){
  const help = $('voteHelp');
  const list = $('candidateList');
  const tallyBox = $('tallyBox');
  const btn = $('castVoteBtn');
  const countdown = $('voteCountdownPill');
  if (!help || !list || !tallyBox || !btn) return;

  const voting = state.voting || {};
  MB.updateCountdownPill(countdown, voting.endsAt);

  if (!voting.open && !voting.closed){
    help.textContent = canVote ? 'Waiting for Admin to open voting...' : 'You cannot vote in this round.';
    list.innerHTML = '';
    tallyBox.innerHTML = '';
    btn.disabled = true;
    delete btn.dataset.forbiddenCandidate;
    return;
  }

  const candidates = voting.candidates || {};
  const votes = {...(voting.votes || {})};
  const items = Object.keys(candidates);

  let myVote = votes[uidVal] || '';
  let forbidUid = '';
  if (me?.specialRole === 'Thrall' && state.originalElderUid){
    const elder = users[state.originalElderUid];
    if (elder && !userIsDead(elder, chars)){
      forbidUid = state.originalElderUid;
      if (myVote === forbidUid){
        delete votes[uidVal];
        myVote = '';
        db.ref(`rooms/${room}/state/voting/votes/${uidVal}`).remove();
      }
    }
  }

  const display = items.map(candidateUid=>{
    const u = users[candidateUid];
    const charName = (u && u.charId && chars[u.charId]) ? baseCharName(chars[u.charId].name) : '';
    const dead = u ? userIsDead(u, chars) : false;
    const charPart = charName ? `${dead ? `<span class="dead-name">${charName}</span>` : charName}${dead ? ' (dead)' : ' (alive)'}` : (dead ? '(dead)' : '(alive)');
    const label = u ? `${u.name}${charName ? ' - ' + charPart : ' ' + charPart}` : candidateUid;
    const blocked = !!forbidUid && forbidUid === candidateUid;
    return {key: candidateUid, label: blocked ? `${label} <span class="muted">(bound)</span>` : label, dead, blocked};
  });

  const youAreCandidate = !!candidates[uidVal];
  if (forbidUid) btn.dataset.forbiddenCandidate = forbidUid;
  else delete btn.dataset.forbiddenCandidate;

  if (voting.open){
    const baseHelp = 'Voting is OPEN. Choose one candidate.';
    const extra = forbidUid ? ' (You may not vote for the Elder while bound.)' : '';
    help.textContent = canVote ? baseHelp + (youAreCandidate ? ' (You are also a candidate.)' : '') + extra : 'Voting is OPEN, but you may not vote.';
    list.innerHTML = display.map(d=>`
      <label class="vote-item">
        <input type="radio" name="voteChoice" value="${d.key}" ${myVote===d.key?'checked':''} ${(d.dead || !canVote || (forbidUid && d.blocked))?'disabled':''}/>
        <span class="vote-label">${d.label}</span>
      </label>`).join('') || '<div class="muted">No candidates yet.</div>';
    btn.disabled = !canVote;
    tallyBox.innerHTML = '<span class="muted">Tally will appear when voting closes.</span>';
  }else{
    help.textContent = 'Voting is CLOSED. Final tally:';
    list.innerHTML = display.map(d=>`<div class="vote-item"><span class="vote-label">${d.label}</span></div>`).join('') || '<div class="muted">No candidates.</div>';
    btn.disabled = true;

    const tally = MB.computeTally(users, chars, votes);
    const tallyLines = display.map(d=>`- ${d.label}: <b class="tally">${tally[d.key]||0}</b>`).join('<br>');
    tallyBox.innerHTML = tallyLines || 'No votes.';
  }
}

$('castVoteBtn').onclick = async ()=>{
  const {room, name, uid: myUid} = activeSession;
  if (!room || !name || !myUid){
    alert('Join a room before casting a vote.');
    return;
  }

  const voting = (activeSession.data.state && activeSession.data.state.voting) || {};
  if (!voting.open){
    alert('Voting is not open right now.');
    return;
  }
  if (!activeSession.canVote){
    alert('You cannot vote right now.');
    return;
  }

  const list = $('candidateList');
  const choice = list ? list.querySelector('input[name="voteChoice"]:checked') : null;
  if (!choice){
    alert('Pick a candidate.');
    return;
  }

  const btn = $('castVoteBtn');
  const forbidden = (btn && btn.dataset.forbiddenCandidate) || '';
  if (forbidden && choice.value === forbidden){
    alert('You are bound to the Elder and cannot vote against them.');
    return;
  }
  await db.ref(`rooms/${room}/state/voting/votes/${myUid}`).set(choice.value);
  alert('Vote recorded.');
};

// Initial render
document.addEventListener('DOMContentLoaded', ()=> refreshActive());
</script>
</body>
</html>



