<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Moonlit Bandanas ‚Äî Game Hub</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Inter:wght@400;600&family=Crimson+Text:wght@400;700&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#0b0b0d; --panel:#131316; --ink:#ececf2; --muted:#a1a1aa;
    --accent:#b11226; --accent2:#e01e37; --ring:0 0 0 2px rgba(224,30,55,.25);
  }
  *{box-sizing:border-box} html,body{height:100%}
  body{
    margin:0;
    background:
      radial-gradient(1200px 600px at 80% -10%, rgba(224,30,55,.10), transparent 60%),
      radial-gradient(800px 500px at -10% 80%, rgba(224,30,55,.08), transparent 60%),
      var(--bg);
    color:var(--ink); font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif;
  }
  header{padding:28px 20px 8px; text-align:center}
  .title{font-family:Cinzel,serif; font-weight:700; font-size:clamp(26px,3.2vw,40px); text-shadow:0 0 30px rgba(224,30,55,.25)}
  .subtitle{color:var(--muted); margin-top:6px}
  .wrap{max-width:1100px; margin:0 auto; padding:20px}
  .tabs{display:flex; gap:8px; justify-content:center; margin:16px 0 24px; flex-wrap:wrap}
  .tabs.hidden{display:none !important}
  .tab{border:1px solid #26262b; background:#121215; color:#d7d7de; padding:10px 14px; border-radius:12px; cursor:pointer}
  .tab[aria-selected="true"]{background:#201116; border-color:#531018; color:#ffd9dd; box-shadow:0 0 24px rgba(177,18,38,.35)}
  .panel{background:linear-gradient(180deg,#121215,#0f0f12); border:1px solid #242428; border-radius:16px; padding:18px}
  .grid{display:grid; gap:16px}
  @media(min-width:980px){.grid-2{grid-template-columns:1.2fr .8fr}}
  label{display:block; font-weight:600; margin:12px 0 6px}
  input, textarea, select{
    width:100%; background:#0d0d10; border:1px solid #26262b; color:#ececf2; border-radius:12px; padding:10px 12px; outline:none; font-size:15px
  }
  input:focus,textarea:focus,select:focus{border-color:#5f101a; box-shadow:var(--ring)}
  textarea{min-height:140px; resize:vertical}
  .btn{display:inline-flex; gap:8px; align-items:center; justify-content:center; background:linear-gradient(180deg,var(--accent2),var(--accent)); color:#fff; border:none; padding:11px 16px; border-radius:12px; cursor:pointer; font-weight:700; box-shadow:0 6px 24px rgba(224,30,55,.25)}
  .btn.secondary{background:#17171b; color:#f0e9eb; border:1px solid #2a2a30; box-shadow:none; font-weight:600}
  .muted{color:var(--muted); font-size:13px}
  .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  .badge{display:inline-block; padding:6px 10px; border-radius:999px; border:1px solid #2a2a30; color:#ececf2; font-size:13px; background:#111114}
  .success{border-color:#224a2b; background:linear-gradient(180deg,#102114,#0d1610); color:#c5f2d1}
  .danger{border-color:#5a0c15; background:linear-gradient(180deg,#1c0b0d,#12080a); color:#ffd9de}
  .info{border-color:#0e3f56; background:linear-gradient(180deg,#0b151a,#0a1317); color:#c8e5f3}
  .divider{height:1px; background:#222226; margin:14px 0}
  .card{background:linear-gradient(180deg,#121215,#0f0f12); border:1px solid #242428; border-radius:16px; padding:14px}
  .mono{font-family:ui-monospace,Menlo,Monaco,Consolas,monospace}
  .center{text-align:center}
  .pill{padding:6px 10px; border-radius:999px; background:#151518; border:1px solid #2a2a30; font-size:12px}

  /* Burned parchment for clues */
  .parchment{
    color:#20160f;
    border:1px solid #3a2a1f;
    border-radius:14px;
    padding:14px 16px;
    font-family:"Crimson Text","Times New Roman",serif;
    box-shadow:0 10px 30px rgba(0,0,0,.45), inset 0 0 24px rgba(0,0,0,.35);
    background:
      radial-gradient(140% 100% at 0% 0%, rgba(0,0,0,.18), transparent 40%),
      radial-gradient(140% 100% at 100% 100%, rgba(0,0,0,.16), transparent 40%),
      radial-gradient(200px 80px at 10% 20%, rgba(70,35,20,.35), transparent 60%),
      radial-gradient(200px 80px at 90% 80%, rgba(70,35,20,.30), transparent 60%),
      repeating-linear-gradient(0deg, rgba(0,0,0,.035), rgba(0,0,0,.035) 2px, transparent 2px, transparent 4px),
      linear-gradient(180deg, #3a2b1f, #2f231a 60%, #2b2118);
    position:relative;
  }
  .parchment:before{
    content:""; position:absolute; inset:-6px; border-radius:18px;
    background:
      radial-gradient(200px 60px at 5% 10%, rgba(0,0,0,.65), transparent 50%),
      radial-gradient(240px 80px at 95% 90%, rgba(0,0,0,.6), transparent 50%),
      radial-gradient(800px 220px at 50% -40px, rgba(0,0,0,.5), transparent 60%),
      radial-gradient(800px 220px at 50% calc(100% + 40px), rgba(0,0,0,.5), transparent 60%);
    pointer-events:none; mix-blend-mode:multiply; opacity:.6; filter: blur(1px);
  }
  .parchment h4{margin:.3rem 0 .2rem; font-size:18px; color:#f2e7d9}
  .parchment .tag{font-size:12px; color:#bda48f}

  /* Checklist */
  .todo{display:flex; align-items:flex-start; gap:10px; padding:10px 12px; border:1px solid #242428; border-radius:12px; margin-top:8px; background:#101014; justify-content:flex-start}
  .todo input[type="checkbox"]{transform:scale(1.2); margin-top:3px}
  .todo.done{opacity:.7}
  .kicker{font-family:Cinzel,serif; font-weight:700; letter-spacing:.4px}

  /* Vote list */
  .vote-list{display:grid; gap:8px}
  .vote-item{display:flex; align-items:center; gap:10px; padding:8px 10px; border:1px solid #242428; border-radius:10px; background:#0f0f13}
  .tally{font-variant-numeric:tabular-nums}

  /* Modal */
  dialog{border:none; border-radius:16px; padding:0; max-width:640px; width:calc(100% - 24px); background:#151519; color:#f0eef3; box-shadow:0 30px 80px rgba(0,0,0,.6)}
  .modal-head{padding:16px 18px; background:#1a0f13; border-bottom:1px solid #2b0e15; font-family:Cinzel,serif}
  .modal-body{padding:16px 18px}
  .modal-actions{padding:12px 18px; display:flex; justify-content:flex-end; gap:10px; border-top:1px solid #232327}
</style>
</head>
<body>
<header>
  <div class="title">Moonlit Bandanas</div>
  <div class="subtitle">Assignments ‚Ä¢ Clues ‚Ä¢ Mob Justice</div>
</header>

<div class="wrap">
  <nav class="tabs" role="tablist" aria-label="Moonlit App" id="topTabs">
    <button class="tab" id="tab-host" role="tab" aria-selected="true">Host Setup</button>
    <button class="tab" id="tab-join" role="tab" aria-selected="false">Join</button>
    <!-- No "Active Mode" tab for players -->
    <button class="tab" id="tab-clues" role="tab" aria-selected="false">Clues</button>
    <button class="tab" id="tab-admin" role="tab" aria-selected="false">Admin</button>
  </nav>

  <!-- HOST SETUP -->
  <section id="panel-host" class="panel" role="tabpanel" aria-labelledby="tab-host">
    <div class="grid grid-2">
      <div>
        <label>Room Code</label>
        <input id="roomCode" placeholder="e.g., REVEL-2025" />
        <div class="muted">Letters/numbers/dashes (3‚Äì30 chars).</div>

        <label style="margin-top:12px">Room Password</label>
        <input id="roomPassword" type="password" placeholder="Password players must enter" />
        <div class="muted">Stored as SHA-256 hash.</div>

        <label style="margin-top:12px">Admin Password (secret)</label>
        <input id="roomAdminPassword" type="password" placeholder="Required to unlock Admin" />
        <div class="muted">Stored as SHA-256 hash.</div>

        <div class="divider"></div>

        <label>Character Pool (name ‚Äî biography, one per line)</label>
        <textarea id="rolePool"></textarea>

        <div class="divider"></div>

        <div class="row">
          <button class="btn" id="createRoomBtn">Create / Reset Room</button>
          <button class="btn secondary" id="fillDefaultsBtn">Reset To Default Characters</button>
        </div>
        <div id="hostStatus" style="margin-top:10px"></div>
      </div>

      <div class="card">
        <b>How it works</b>
        <ul>
          <li>Host creates a room with passwords.</li>
          <li>Players join and receive a random unclaimed character.</li>
          <li>Admin starts the game when ready. Before that, players only see their character (and role, if any).</li>
          <li>Admin controls rounds, clues, voting, deaths, and checks win conditions.</li>
        </ul>
      </div>
    </div>
  </section>

  <!-- JOIN -->
  <section id="panel-join" class="panel" role="tabpanel" aria-labelledby="tab-join" hidden>
    <div class="grid">
      <div>
        <label>Room Code</label>
        <input id="joinRoom" placeholder="Enter room code exactly" />
      </div>
      <div>
        <label>Room Password</label>
        <input id="joinPass" type="password" placeholder="Enter the room password" />
      </div>
      <div>
        <label>Your Real Name</label>
        <input id="realName" placeholder="e.g., Alex Johnson" />
      </div>
      <div class="row">
        <button class="btn" id="assignBtn">Get My Character</button>
        <button class="btn secondary" id="revealMineBtn">Reveal Mine Again</button>
      </div>
      <div id="assignStatus"></div>

      <div id="myRoleCard" class="card" style="display:none; margin-top:12px">
        <div class="row"><span class="badge success">Assigned</span></div>
        <h3 id="roleName" style="margin:8px 0 6px; font-family:Cinzel,serif"></h3>
        <div class="muted">When the host starts, your objectives will unlock.</div>
        <div class="row" style="margin-top:10px">
          <button class="btn secondary" id="copyRoleBtn">Copy to Clipboard</button>
        </div>
      </div>
    </div>
  </section>

  <!-- ACTIVE (no tab; hidden by default) -->
  <section id="panel-active" class="panel" hidden>
    <div class="grid">
      <div class="row" style="justify-content:space-between">
        <div class="row" style="gap:12px">
          <span class="pill" id="activeRoomPill">Room: ‚Äî</span>
          <span class="pill" id="activeNamePill">Player: ‚Äî</span>
          <span class="pill" id="activeCharPill">Character: ‚Äî</span>
          <span class="pill" id="roundPill">Round: ‚Äî</span>
          <span class="pill" id="voteStatusPill">Vote: ‚Äî</span>
          <span class="pill" id="voteCountdownPill">‚è≥ ‚Äî</span>
        </div>
        <button class="btn secondary" id="refreshActiveBtn">Refresh</button>
      </div>

      <div class="divider"></div>

      <!-- Character summary + Role details -->
      <div class="card" id="charSummaryBox">
        <h3 class="kicker">Your Character</h3>
        <div id="charSummaryText" class="muted">‚Äî</div>
        <div id="roleDetailsBox" style="margin-top:10px"></div>
      </div>

      <!-- WAITING STATE -->
      <div id="waitingState" class="card">
        <h3 class="kicker">Waiting for Host to Start</h3>
        <div class="muted">You‚Äôll see objectives, notes, and Mob Justice once the game begins.</div>
      </div>

      <div id="liveGameBlock" hidden>
        <div class="grid grid-2">
          <div>
            <h3 class="kicker">Your Objectives</h3>
            <div id="todoList" class="muted">‚Äî</div>
          </div>
          <div>
            <h3 class="kicker">Notes (private)</h3>
            <textarea id="notesBox" placeholder="Jot suspects, alibis, or reminders‚Ä¶ (saved on this device)"></textarea>
            <div class="row" style="margin-top:8px">
              <button class="btn secondary" id="saveNotesBtn">Save Notes</button>
              <span class="muted">Notes are not uploaded.</span>
            </div>
          </div>
        </div>

        <div class="divider"></div>

        <!-- MOB JUSTICE (player) -->
        <div class="card">
          <h3 class="kicker">Mob Justice</h3>
          <div id="voteBlock">
            <div class="muted" id="voteHelp">Waiting for Admin to open voting‚Ä¶</div>
            <div id="candidateList" class="vote-list" style="margin-top:8px"></div>
            <div class="row" style="margin-top:10px">
              <button class="btn" id="castVoteBtn">Cast / Update Vote</button>
              <span class="muted">One vote per round; you can change it until voting closes.</span>
            </div>
            <div class="divider"></div>
            <div id="tallyBox" class="muted"></div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- CLUES -->
  <section id="panel-clues" class="panel" role="tabpanel" aria-labelledby="tab-clues" hidden>
    <div class="grid">
      <div class="row" style="gap:12px">
        <span class="pill">Revealed Clues</span>
        <button class="btn secondary" id="refreshCluesBtn">Refresh</button>
      </div>
      <div id="clueList" class="grid" style="gap:14px; margin-top:8px">
        <div class="muted">No clues revealed yet.</div>
      </div>
    </div>
  </section>

  <!-- ADMIN -->
  <section id="panel-admin" class="panel" role="tabpanel" aria-labelledby="tab-admin" hidden>
    <div class="grid">
      <div class="card">
        <b>Admin Access</b>
        <div class="row" style="gap:12px; margin-top:8px">
          <div style="flex:1">
            <label>Room Code</label>
            <input id="adminRoom" placeholder="Room code" />
          </div>
          <div style="flex:1">
            <label>Admin Password</label>
            <input id="adminPass" type="password" placeholder="Admin password" />
          </div>
          <button class="btn" id="adminAuthBtn">Unlock Admin</button>
          <div id="adminAuthStatus"></div>
        </div>
      </div>

      <div class="grid grid-2">
        <div class="card">
          <h3>Characters</h3>
          <div class="row" style="gap:12px; flex-wrap:wrap">
            <button class="btn secondary" id="loadRoomBtn">Load Lists</button>
            <button class="btn secondary" id="watchRoomBtn">Live Watch</button>
            <select id="deadToggleSelect"><option value="">‚Äî select claimed player ‚Äî</option></select>
            <button class="btn" id="markDeadBtn">Mark Dead</button>
            <button class="btn secondary" id="markAliveBtn">Mark Alive</button>
          </div>
          <div class="divider"></div>
          <h4>Unclaimed</h4>
          <div id="unclaimedBox" class="muted">‚Äî</div>
          <div class="divider"></div>
          <h4>Claimed</h4>
          <div id="claimedBox" class="muted">‚Äî</div>
        </div>

        <div class="card">
          <h3>Assign Special Roles</h3>
          <div class="muted">Select a claimed player and assign.</div>
          <div class="row" style="gap:12px; margin-top:8px">
            <select id="playerSelect"><option value="">‚Äî select player ‚Äî</option></select>
            <select id="specialSelect">
              <option value="">(none)</option>
              <option>Elder Vampire</option>
              <option>Lesser Vampire</option>
              <option>Thrall</option>
              <option>Night Warden</option>
              <option>Mirrorcloak</option>
              <option>Gravespeaker</option>
            </select>
            <button class="btn" id="assignSpecialBtn">Assign</button>
          </div>
          <div id="specialStatus" style="margin-top:8px"></div>
        </div>
      </div>

      <!-- ROUND, GAME & VOTING CONTROLS -->
      <div class="card">
        <h3>Game, Round & Mob Justice Controls</h3>
        <div class="row" style="gap:10px; align-items:flex-end; flex-wrap:wrap">
          <div>
            <label>Game State</label>
            <input id="gameStateDisplay" disabled />
          </div>
          <button class="btn" id="startGameBtn">Start Game</button>
          <button class="btn secondary" id="stopGameBtn">Back to Waiting</button>
        </div>

        <div class="divider"></div>

        <div class="row" style="gap:10px; align-items:flex-end">
          <div>
            <label>Round</label>
            <input id="adminRoundDisplay" disabled />
          </div>
          <button class="btn" id="nextRoundBtn">Advance to Next Round</button>
        </div>

        <div class="divider"></div>

        <div class="row" style="gap:10px; align-items:flex-end; flex-wrap:wrap">
          <div>
            <label>Voting Status</label>
            <input id="votingStatusDisplay" disabled />
          </div>
          <button class="btn secondary" id="start5minVoteBtn">Start 5-Minute Vote</button>
          <button class="btn secondary" id="openVotingBtn">Open Voting</button>
          <button class="btn secondary" id="closeVotingBtn">Close Voting</button>
          <button class="btn secondary" id="clearVotingBtn">Clear Candidates & Votes</button>
        </div>

        <div class="divider"></div>

        <div class="row" style="gap:10px; align-items:flex-end; flex-wrap:wrap">
          <select id="candidatePlayerSelect"><option value="">‚Äî add candidate (claimed players) ‚Äî</option></select>
          <button class="btn" id="addCandidateBtn">Add Candidate</button>
          <select id="removeCandidateSelect"><option value="">‚Äî remove candidate ‚Äî</option></select>
          <button class="btn secondary" id="removeCandidateBtn">Remove</button>
        </div>

        <div class="divider"></div>

        <div id="adminTallyBox" class="muted">No votes yet.</div>
      </div>

      <!-- CSV IMPORT -->
      <div class="card">
        <h3>Import via CSV</h3>
        <div class="row" style="gap:14px; align-items:flex-end; flex-wrap:wrap">
          <div>
            <label>Characters CSV (name,description)</label>
            <input id="csvChars" type="file" accept=".csv" />
          </div>
          <button class="btn" id="importCharsBtn">Import Characters</button>
          <button class="btn secondary" id="useDefaultCharsBtn">Use Default Characters</button>
        </div>
        <div class="divider"></div>
        <div class="row" style="gap:14px; align-items:flex-end; flex-wrap:wrap">
          <div>
            <label>Clues CSV (id,title,body)</label>
            <input id="csvClues" type="file" accept=".csv" />
          </div>
          <button class="btn" id="importCluesBtn">Import Clues</button>
          <button class="btn secondary" id="useDefaultCluesBtn">Use Default Clues</button>
        </div>
        <div class="muted" id="csvStatus" style="margin-top:8px"></div>
      </div>
    </div>
  </section>

  <p class="center muted" style="margin:18px 0 40px">
    Theme: reds & blacks ‚Ä¢ Burned parchment clues ‚Ä¢ Mob Justice voting ‚Ä¢ Good hunting ü©∏
  </p>
</div>

<!-- Result modal -->
<dialog id="resultModal">
  <div class="modal-head" id="modalTitle">Result</div>
  <div class="modal-body" id="modalBody"></div>
  <div class="modal-actions">
    <button class="btn secondary" id="closeModalBtn">Close</button>
  </div>
</dialog>

<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-database-compat.js"></script>

<script>
/* Tabs */
const TABS = [
  {btn:'tab-host',   panel:'panel-host'},
  {btn:'tab-join',   panel:'panel-join'},
  {btn:'tab-clues',  panel:'panel-clues'},
  {btn:'tab-admin',  panel:'panel-admin'},
];
TABS.forEach(({btn,panel})=>{
  document.getElementById(btn).addEventListener('click', ()=>{
    TABS.forEach(x=>{
      document.getElementById(x.btn).setAttribute('aria-selected', x.btn===btn ? 'true':'false');
      document.getElementById(x.panel).hidden = x.panel!==panel;
    });
    // Keep Active panel hidden unless explicitly entering Active mode
    document.getElementById('panel-active').hidden = true;
    document.getElementById('topTabs').classList.remove('hidden');
  });
});

/* Character defaults with cleaner bios */
const DEFAULT_CHAR_OBJS = [
  {name:"V. M. Pyre", desc:"A traveling fire performer who collects matchbooks; friends with Raven Cask and often helps Ember Hollow test new candles."},
  {name:"Ashen Vale", desc:"A practical apothecary; checks in on Mist Graves and trades herbs with Ivy Haze."},
  {name:"Gloom Ivy", desc:"A lantern carver; buys glass from Cinder Wight and swaps ideas with Sable Nyx."},
  {name:"Hex Rowan", desc:"A confident games host at Ebon Thatch‚Äôs inn; partners with Patch Wylde for fair play."},
  {name:"Noct Rune", desc:"A quiet night-note taker; compares routes with Lumen Wolfe and files summaries with Slate Crowe."},
  {name:"Cinder Wight", desc:"A glassblower; supplies Gloom Ivy with panes and Ember Hollow with jars."},
  {name:"Marrow Quinn", desc:"An anatomy sketcher; consults Ashen Vale and coordinates storage with Crypt Alder."},
  {name:"Ebon Thatch", desc:"An easygoing innkeeper; seats Hex Rowan‚Äôs games and pilots new brews from Raven Cask."},
  {name:"Sable Nyx", desc:"A perfumer; works with Gloom Ivy on scent and light and buys rare ingredients from Dusk Mariner."},
  {name:"Thorn Ever", desc:"A steady bookkeeper; respects Slate Crowe‚Äôs records and once helped V. M. Pyre with a tab."},
  {name:"Cob Webber", desc:"A trap and latch maker; fits cellar locks for Ebon Thatch and hardware for Rune Lantern."},
  {name:"Hallow Reed", desc:"A folk singer; performs with Piper Shade and sometimes refines lyrics with Echo Vane."},
  {name:"Mist Graves", desc:"A gentle sleepwalker; checks in with Ashen Vale and appreciates Noct Rune‚Äôs practical advice."},
  {name:"Piper Shade", desc:"A flute seller and player; plays with Hallow Reed and prefers Rune Lantern‚Äôs reliable lamps."},
  {name:"Rune Lantern", desc:"A lantern tinker; keeps a simple test for bad wicks and built a nightlight for Mist Graves."},
  {name:"Bramble Kite", desc:"A quick messenger; coordinates fog runs with Dusk Mariner and uses Slate Crowe‚Äôs code marks."},
  {name:"Frost Morn", desc:"An early-rising ice seller; stores blocks at Ebon Thatch‚Äôs and supplies Ember Hollow in summer."},
  {name:"Ember Hollow", desc:"A methodical candlemaker; works with Cinder Wight for jars and files rumor notes from Echo Vane."},
  {name:"Wisp Harrow", desc:"A story collector; listens to Hallow Reed‚Äôs songs and cross-checks with Echo Vane."},
  {name:"Crypt Alder", desc:"A quartermaster; syncs inventories with Slate Crowe and confirms deliveries with Raven Cask."},
  {name:"Omen Lark", desc:"A friendly street reader; teases Hex Rowan about dice and suggests mask ideas to Gourd Wilder."},
  {name:"Raven Cask", desc:"A small-batch brewer; tests flavors with Ebon Thatch and swaps tasting notes with V. M. Pyre."},
  {name:"Night Jar", desc:"A curio buyer and reseller; trades with Patch Wylde and orders sturdy packaging from Cob Webber."},
  {name:"Lumen Wolfe", desc:"A night patrol volunteer; compares notes with Noct Rune and buys long-burn candles from Ember Hollow."},
  {name:"Patch Wylde", desc:"A card worker; partners with Hex Rowan on game nights and likes a door-side chair at the inn."},
  {name:"Echo Vane", desc:"A rumor collector who double-sources; revises verses with Hallow Reed and shares leads with Ember Hollow."},
  {name:"Dusk Mariner", desc:"A ferry operator on the bog path; supplies rope to Mist Graves and passes sealed notes to Noct Rune."},
  {name:"Ivy Haze", desc:"An herb gatherer; trades with Ashen Vale and brings leaf samples to Gloom Ivy to test lantern heat."},
  {name:"Slate Crowe", desc:"A record keeper; checks Thorn Ever‚Äôs tallies and gives Bramble Kite simple signal codes."},
  {name:"Gourd Wilder", desc:"A mask artisan; takes orders from Night Jar, builds guards for Cob Webber, and prioritizes comfortable fits."}
];

const DEFAULT_TASKS = [
  "Learn two names and one hobby.",
  "Trade a small trinket or token with someone.",
  "Share one rumor or clue you‚Äôve heard.",
  "Publicly vouch for or accuse exactly one person.",
  "Find someone who matches a clue and ask them about it."
];

const DEFAULT_CLUES = [
  {id:"E1", title:"The Dimming of Candles", body:"In the glassblower‚Äôs stall, a trio of candles guttered all at once, as though a mouth had drawn in the room‚Äôs breath. Witnesses swore the figure who passed by wore a ring that drank the light. They left no soot, only a whisper of clove."},
  {id:"E2", title:"The Whispering Step", body:"Near the square of empty masks, a watcher heard footfalls that seemed to land after their own echoes. The gait was even, decisive, and oddly weightless‚Äîas if the night itself cushioned each stride."},
  {id:"E3", title:"Threads by the Well", body:"By the old wishing well, a single thread of deep red snagged on weathered stone, the shade of a harvest moon. No cloak nearby bore that hue‚Äîperhaps it belonged to a sash tied close to the heart."},
  {id:"E4", title:"The Breath That Wasn‚Äôt", body:"Flutes lay in their case, and yet a mourning note hung in the air as if blown by no mouth at all. The player who lingered exhaled fog though the night was warm, and smiled without teeth."},
  {id:"E5", title:"The Lantern That Blinked", body:"A tinker‚Äôs lantern fluttered near a laughing circle‚Äîthen steadied when a single figure drew near and asked no questions. Lies make it flicker, the tinker swears."},
  {id:"E6", title:"A Toast to Nowhere", body:"Someone raised an empty cup and murmured a phrase not quite language, not quite song. Those within earshot forgot a name they had just learned. The smell of old cellars followed."},
  {id:"E7", title:"Left Hand of Dusk", body:"Chalk tallies were scrawled backward on a ledger margin, lines neat yet mirrored. Whoever wrote them favored the left hand and the calm of twilight."},
  {id:"E8", title:"The Silver Coin Gone Cold", body:"A coin traded thrice in an hour turned cold enough to mist a mirror. The last to hold it tucked it away with clinical care, as though cataloging a specimen."},
  {id:"L1", title:"The Heir in the Crowd", body:"When the bells tolled, a shadow took shelter in another‚Äôs laughter. The heir does not stand alone; they orbit a brighter star to dim their edges."},
  {id:"L2", title:"The Smile That Stops", body:"A chuckle rang out, crisp as cracked ice, but ended sharply‚Äîhabit, not humor. Hands drifted to pockets where keys or coins clicked in nervous code."},
  {id:"L3", title:"Scent of Wet Stone", body:"On the path to the bog ferries, a scent of wet stone trailed someone who avoids shallow water, preferring docks‚Äô deeper quiet."},
  {id:"L4", title:"The Double Shadow", body:"Two silhouettes overlapped beneath a single lantern: one tall and still, the other shifting, impatient. Only one turned when hailed."},
  {id:"L5", title:"The Hat with No Owner", body:"A brim with a feather of ash-gray was left on a chair that always faces the door. No one claimed it‚Äîbut more than one person looked too long at its seat."},
  {id:"L6", title:"Ink Under the Nail", body:"A knuckle brushed paper and left a crescent of black under the nail‚Äîold ink that no wash could fully banish."},
  {id:"D1", title:"Red Herring: The Laughing Mask", body:"A maskmaker insisted a mask smiled on its own when a brewer sang off-key. Sweet nonsense, perhaps, or theater."},
  {id:"D2", title:"Red Herring: The Garlic Fable", body:"Someone swore they saw a cloaked patron recoil from garlic‚Ä¶ but the cloves were candied. Theatrical groaning followed."}
];

/* Firebase (paste your config) */
const firebaseConfig = {
  apiKey: "AIzaSyDNqVMgr5CHIe-ajgikCaJp0kzB2CpbOWs",
  authDomain: "murdermystery-cd241.firebaseapp.com",
  databaseURL: "https://murdermystery-cd241-default-rtdb.firebaseio.com",
  projectId: "murdermystery-cd241",
  storageBucket: "murdermystery-cd241.firebasestorage.app",
  messagingSenderId: "724748560349",
  appId: "1:724748560349:web:4ba1d4f5ed874419167834",
  measurementId: "G-7RS065D3HZ"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.database();

/* Helpers & modal */
const byId = id => document.getElementById(id);
const setPill = (id,t)=> byId(id).textContent = t;
const hashSHA256 = async (text)=>{
  const enc = new TextEncoder().encode(text);
  const buf = await crypto.subtle.digest('SHA-256', enc);
  return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join('');
};
function setCookie(name,value,days){
  const d = new Date(); d.setTime(d.getTime() + (days*24*60*60*1000));
  document.cookie = `${name}=${encodeURIComponent(value)}; expires=${d.toUTCString()}; path=/; SameSite=Lax`;
}
function getCookie(name){
  const m = document.cookie.match(new RegExp('(^| )'+name+'=([^;]+)')); return m ? decodeURIComponent(m[2]) : '';
}
const modal = byId('resultModal');
byId('closeModalBtn').addEventListener('click', ()=> modal.close());
function popup(title, html){
  byId('modalTitle').textContent = title;
  byId('modalBody').innerHTML = html;
  modal.showModal();
}

/* Always show Admin tab; features still require admin password */
function showAdminTab(){ byId('tab-admin').style.display = ''; }
showAdminTab();

/* Host Setup */
const rolePoolEl = byId('rolePool');
byId('fillDefaultsBtn').addEventListener('click', ()=>{
  rolePoolEl.value = DEFAULT_CHAR_OBJS.map(o=>`${o.name} ‚Äî ${o.desc}`).join("\n");
});
byId('fillDefaultsBtn').click();

byId('createRoomBtn').addEventListener('click', async ()=>{
  const codeRaw = (byId('roomCode').value||'').trim();
  const passRaw = (byId('roomPassword').value||'').trim();
  const adminPassRaw = (byId('roomAdminPassword').value||'').trim();
  const hostStatus = byId('hostStatus');
  if (!/^[A-Za-z0-9-]{3,30}$/.test(codeRaw)){ hostStatus.innerHTML = `<span class="badge danger">Invalid room code</span>`; return; }
  if (!passRaw || passRaw.length < 4){ hostStatus.innerHTML = `<span class="badge danger">Room password too short</span>`; return; }
  if (!adminPassRaw || adminPassRaw.length < 6){ hostStatus.innerHTML = `<span class="badge danger">Admin password too short</span>`; return; }
  const code = codeRaw.toUpperCase();
  const passHash = await hashSHA256(passRaw);
  const adminHash = await hashSHA256(adminPassRaw);
  const lines = (rolePoolEl.value||'').split('\n').map(s=>s.trim()).filter(Boolean);
  const unique = [...new Set(lines)];
  if (!unique.length){ hostStatus.innerHTML = `<span class="badge danger">No characters provided</span>`; return; }
  const chars = {};
  unique.forEach((line, i)=>{
    const id = 'c_'+i.toString().padStart(3,'0');
    const [name, ...rest] = line.split('‚Äî');
    const nm = (name||'').trim();
    const desc = (rest.join('‚Äî')||'').trim() || null;
    chars[id] = {name: nm + (desc? ` ‚Äî ${desc}`:''), desc, claimedBy:null, claimedAt:null, dead:false};
  });
  const clues = {}; DEFAULT_CLUES.forEach(c=>{ clues[c.id] = {title:c.title, body:c.body, revealed:false}; });
  const state = { gameStarted:false, round: 1, voting: { open:false, closed:false, candidates:null, votes:null, endsAt:null } };
  try{
    await db.ref(`rooms/${code}`).set({
      passHash, adminHash, createdAt: Date.now(),
      characters: chars, users: null, clues, state
    });
    hostStatus.innerHTML = `<span class="badge success">Room ready</span> <b class="mono">${code}</b>`;
    localStorage.setItem('mb_room_host', code);
  }catch(e){
    hostStatus.innerHTML = `<span class="badge danger">Error</span> ${e.message}`;
  }
});

/* Join & Claim */
function saveLocal(room,name,charId,charName){
  localStorage.setItem('mb_room', room);
  localStorage.setItem('mb_name', name);
  localStorage.setItem('mb_charId', charId);
  localStorage.setItem('mb_charName', charName);
}
function getUid(room,name){ return btoa(`${name}::${room}`).replace(/=+$/,''); }
async function verifyRoomPassword(room, pass){
  const snap = await db.ref(`rooms/${room}/passHash`).get();
  if (!snap.exists()) throw new Error('Room not found');
  return (await hashSHA256(pass)) === snap.val();
}

async function claimCharacter(room, pass, realName){
  const r = room.toUpperCase();
  const ok = await verifyRoomPassword(r, pass);
  if (!ok) throw new Error('Incorrect password');
  const rolesSnap = await db.ref(`rooms/${r}/characters`).get();
  if (!rolesSnap.exists()) throw new Error('No characters in this room');
  const entries = Object.entries(rolesSnap.val());
  const unclaimed = entries.filter(([id,c])=>!c.claimedBy).map(([id,c])=>({id,name:c.name}));
  if (!unclaimed.length) throw new Error('All characters are taken');
  const pick = unclaimed[Math.floor(Math.random()*unclaimed.length)];
  const ref = db.ref(`rooms/${r}/characters/${pick.id}`);
  const res = await new Promise((resolve, reject)=>{
    ref.transaction(curr=>{
      if (!curr) return curr;
      if (curr.claimedBy) return;
      return {...curr, claimedBy: realName, claimedAt: Date.now()};
    }, (error, committed, snapshot)=>{
      if (error) return reject(error);
      resolve({committed, snapshot});
    }, false);
  });
  if (!res.committed) return claimCharacter(r, pass, realName);

  const uid = getUid(r, realName);
  await new Promise((resolve, reject)=>{
    db.ref(`rooms/${r}/users/${uid}`).transaction(curr=>{
      if (curr) return curr;
      return {
        name: realName,
        charId: pick.id,
        specialRole: null,
        tasks: DEFAULT_TASKS.map(t=>({text:t, done:false})),
        dead:false
      };
    }, (error, committed)=>{
      if (error) return reject(error);
      resolve(committed);
    }, false);
  });
  saveLocal(r, realName, pick.id, pick.name);
  setCookie('mb_room', r, 30);
  setCookie('mb_name', realName, 30);
  return pick.name;
}

byId('assignBtn').addEventListener('click', async ()=>{
  const room = (byId('joinRoom').value||'').trim();
  const pass = (byId('joinPass').value||'').trim();
  const name = (byId('realName').value||'').trim();
  const status = byId('assignStatus');
  if (!room || !pass || !name){ status.innerHTML = `<span class="badge danger">Enter room, password, and name</span>`; return; }
  status.textContent = 'Assigning‚Ä¶';
  try{
    const charName = await claimCharacter(room, pass, name);
    status.innerHTML = `<span class="badge success">Assigned</span>`;
    byId('roleName').textContent = `${charName} ‚Äî assigned to ${name}`;
    byId('myRoleCard').style.display = '';
    collapseToActiveOnly();
    refreshActive();
  }catch(e){
    status.innerHTML = `<span class="badge danger">Error</span> ${e.message}`;
  }
});

byId('revealMineBtn').addEventListener('click', async ()=>{
  const room = (byId('joinRoom').value||'').trim().toUpperCase();
  const pass = (byId('joinPass').value||'').trim();
  const name = (byId('realName').value||'').trim();
  const status = byId('assignStatus');
  if (!room || !pass || !name){ status.innerHTML=`<span class="badge danger">Enter room, password, and name</span>`; return; }
  try{
    const ok = await verifyRoomPassword(room, pass);
    if (!ok) throw new Error('Incorrect password');
    const uid = getUid(room, name);
    const uSnap = await db.ref(`rooms/${room}/users/${uid}`).get();
    if (!uSnap.exists()){ status.innerHTML=`<span class="badge danger">No prior assignment</span>`; return; }
    const {charId} = uSnap.val();
    const rSnap = await db.ref(`rooms/${room}/characters/${charId}`).get();
    const charName = rSnap.exists() ? rSnap.val().name : '(unknown)';
    saveLocal(room, name, charId, charName);
    setCookie('mb_room', room, 30);
    setCookie('mb_name', name, 30);
    byId('roleName').textContent = `${charName} ‚Äî assigned to ${name}`;
    byId('myRoleCard').style.display = '';
    status.innerHTML = `<span class="badge success">Found</span>`;
    collapseToActiveOnly();
    refreshActive();
  }catch(e){
    status.innerHTML = `<span class="badge danger">Error</span> ${e.message}`;
  }
});

byId('copyRoleBtn').addEventListener('click', async ()=>{
  const txt = byId('roleName').textContent;
  try{ await navigator.clipboard.writeText(txt); }catch{}
  alert('Copied:\n'+txt);
});

/* Active Mode visibility guards */
function loadLocalIdentity(){
  return {
    room: localStorage.getItem('mb_room') || '',
    name: localStorage.getItem('mb_name') || '',
    charId: localStorage.getItem('mb_charId') || '',
    charName: localStorage.getItem('mb_charName') || '',
  };
}
async function getRoomState(room){
  const snap = await db.ref(`rooms/${room}/state`).get();
  if (!snap.exists()) return { gameStarted:false, round:1, voting:{open:false,closed:false,candidates:null,votes:null,endsAt:null} };
  return snap.val();
}

async function refreshActive(){
  const {room,name,charId,charName} = loadLocalIdentity();

  // If player has no character, keep Active hidden and show normal tabs
  const hasChar = !!charId;
  if (!hasChar){
    byId('panel-active').hidden = true;
    byId('topTabs').classList.remove('hidden');
    return;
  }

  // Player has a character: show Active panel
  setPill('activeRoomPill', `Room: ${room||'‚Äî'}`);
  setPill('activeNamePill', `Player: ${name||'‚Äî'}`);
  setPill('activeCharPill', `Character: ${charName||'‚Äî'}`);

  const uid = getUid(room, name);
  const [userSnap, stateSnap, charsSnap, usersSnap] = await Promise.all([
    db.ref(`rooms/${room}/users/${uid}`).get(),
    db.ref(`rooms/${room}/state`).get(),
    db.ref(`rooms/${room}/characters`).get(),
    db.ref(`rooms/${room}/users`).get()
  ]);
  const state = stateSnap.exists()? stateSnap.val(): {gameStarted:false, round:1, voting:{}};
  const voting = state.voting || {};
  const chars = charsSnap.exists()? charsSnap.val(): {};
  const users = usersSnap.exists()? usersSnap.val(): {};

  setPill('roundPill', `Round: ${state.round||1}`);
  setPill('voteStatusPill', `Vote: ${voting.open ? 'OPEN' : (voting.closed ? 'CLOSED' : '‚Äî')}`);
  updateCountdownPill(voting.endsAt);

  if (!userSnap.exists()){
    byId('charSummaryText').innerHTML = '‚Äî';
    byId('roleDetailsBox').innerHTML = '';
    byId('waitingState').hidden = false;
    byId('liveGameBlock').hidden = true;
    byId('panel-active').hidden = false;
  }else{
    const me = userSnap.val();

    // Character summary (use full combined name string; desc already included in characters.name)
    const charRec = me.charId && chars[me.charId] ? chars[me.charId] : null;
    const charLine = charRec ? charRec.name : (charName||'‚Äî');
    byId('charSummaryText').innerHTML = `<div><b>${charLine}</b></div>`;

    // Role details (inline; villain visibility)
    byId('roleDetailsBox').innerHTML = renderRoleDetails(me, users, chars);

    // Waiting vs live
    if (!state.gameStarted){
      byId('waitingState').hidden = false;
      byId('liveGameBlock').hidden = true;
    }else{
      byId('waitingState').hidden = true;
      byId('liveGameBlock').hidden = false;

      // Objectives: one new per round (cumulative)
      const toShow = Math.min(me.tasks?.length||0, state.round||1);
      const tasks = (me.tasks||[]).slice(0, toShow);
      const list = tasks.map((t,i)=>`
        <label class="todo ${t.done?'done':''}">
          <input type="checkbox" data-ix="${i}" ${t.done?'checked':''}/>
          <div>${t.text}</div>
        </label>`).join('');
      byId('todoList').innerHTML = list || '<div class="muted">No tasks found.</div>';
      [...byId('todoList').querySelectorAll('input[type="checkbox"]')].forEach(cb=>{
        cb.addEventListener('change', async (e)=>{
          const ix = Number(e.target.getAttribute('data-ix'));
          await db.ref(`rooms/${room}/users/${uid}/tasks/${ix}/done`).set(e.target.checked);
          refreshActive();
        });
      });

      await renderPlayerVoting(room, uid, state);
    }

    byId('panel-active').hidden = false;
  }

  // Hide all tabs for regular players while in Active (unless admin unlocked)
  const isAdminUnlocked = localStorage.getItem('mb_is_admin') === '1';
  if (!isAdminUnlocked){
    byId('topTabs').classList.add('hidden');
  }
}
byId('refreshActiveBtn').addEventListener('click', refreshActive);

byId('saveNotesBtn').addEventListener('click', ()=>{
  const {room,name} = loadLocalIdentity();
  if (!room || !name){ alert('Join first.'); return; }
  const key = `mb_notes_${room}_${name}`;
  localStorage.setItem(key, byId('notesBox').value);
  alert('Notes saved.');
});

/* Countdown pill */
let countdownTimer=null;
function updateCountdownPill(endsAt){
  if (countdownTimer){ clearInterval(countdownTimer); countdownTimer=null; }
  const pill = byId('voteCountdownPill');
  if (!endsAt){ pill.textContent = '‚è≥ ‚Äî'; return; }
  function tick(){
    const ms = Math.max(0, endsAt - Date.now());
    const m = Math.floor(ms/60000), s = Math.floor((ms%60000)/1000).toString().padStart(2,'0');
    pill.textContent = `‚è≥ ${m}:${s}`;
    if (ms<=0 && countdownTimer){ clearInterval(countdownTimer); countdownTimer=null; }
  }
  tick();
  countdownTimer = setInterval(tick, 1000);
}

/* Role details rendering & villain visibility */
function aliveStatus(u, chars){ const dead = u?.dead || (u?.charId && chars[u.charId]?.dead); return dead ? ' (dead)' : ' (alive)'; }
function roleDetailsText(role){
  switch(role){
    case 'Elder Vampire': return 'Primary killer. One target per round, and +1 additional kill each round (bandana snatch). Knows the Lesser Vampire and the Thrall.';
    case 'Lesser Vampire': return 'Succeeds the Elder upon Elder‚Äôs death. Knows the Elder and the Thrall. Has no thrall.';
    case 'Thrall': return 'Once-per-game compelled kill on Elder‚Äôs command; obeys Elder‚Äôs orders. Freed if the Elder dies.';
    case 'Night Warden': return 'Openly armed hunter (nerf blaster). May eliminate one target per round. May hit innocent or vampire.';
    case 'Mirrorcloak': return 'Hidden avenger. If attacked by the vampire or thrall, the attacker dies instantly.';
    case 'Gravespeaker': return 'Medium. After each death, may speak with the dead; each spirit can publicly clear one other player as innocent.';
    default: return null;
  }
}
function renderRoleDetails(me, users, chars){
  if (!me.specialRole) return '';
  const base = `<div class="card" style="margin-top:8px">
      <div><b>Role:</b> ${me.specialRole}</div>
      <div class="muted" style="margin-top:6px">${roleDetailsText(me.specialRole)||''}</div>`;
  if (me.specialRole === 'Elder Vampire' || me.specialRole === 'Lesser Vampire'){
    let elder=null, lesser=null, thrall=null;
    for (const [uid,u] of Object.entries(users||{})){
      if (u.specialRole === 'Elder Vampire') elder = {uid,u};
      if (u.specialRole === 'Lesser Vampire') lesser = {uid,u};
      if (u.specialRole === 'Thrall') thrall = {uid,u};
    }
    const lines=[];
    if (elder) lines.push(`Elder Vampire: <b>${elder.u.name}</b>${aliveStatus(elder.u, chars)}`);
    if (lesser) lines.push(`Lesser Vampire: <b>${lesser.u.name}</b>${aliveStatus(lesser.u, chars)}`);
    if (thrall) lines.push(`Thrall: <b>${thrall.u.name}</b>${aliveStatus(thrall.u, chars)}`);
    return base + (lines.length? `<div style="margin-top:10px">${lines.map(x=>`‚Ä¢ ${x}`).join('<br>')}</div>`:'') + `</div>`;
  }
  if (me.specialRole === 'Thrall'){
    let elder=null;
    for (const [uid,u] of Object.entries(users||{})){
      if (u.specialRole === 'Elder Vampire') elder = {uid,u};
    }
    const freed = elder ? (elder.u.dead || (elder.u.charId && chars[elder.u.charId]?.dead)) : false;
    const line = elder ? `Elder Vampire: <b>${elder.u.name}</b>${aliveStatus(elder.u, chars)}${freed?' ‚Äî you are <b>SET FREE</b>.':''}` : 'Elder Vampire: (unknown)';
    return base + `<div style="margin-top:10px">‚Ä¢ ${line}</div></div>`;
  }
  return base + `</div>`;
}

/* Player voting UI */
async function renderPlayerVoting(room, uid, state){
  const help = byId('voteHelp'), list = byId('candidateList'), tallyBox = byId('tallyBox');
  const btn = byId('castVoteBtn');
  const voting = state.voting || {open:false,closed:false};
  updateCountdownPill(voting.endsAt);
  if (!voting.open && !voting.closed){
    help.textContent = 'Waiting for Admin to open voting‚Ä¶';
    list.innerHTML = ''; tallyBox.innerHTML = ''; btn.disabled = true; return;
  }
  const [usersSnap, charsSnap] = await Promise.all([
    db.ref(`rooms/${room}/users`).get(),
    db.ref(`rooms/${room}/characters`).get()
  ]);
  const users = usersSnap.exists() ? usersSnap.val() : {};
  const chars = charsSnap.exists() ? charsSnap.val() : {};
  const candidates = voting.candidates || {};
  const votes = voting.votes || {};
  const items = Object.keys(candidates);
  const display = items.map(k=>{
    const u = users[k]; const charName = u && u.charId && chars[u.charId] ? chars[u.charId].name : '';
    const dead = u?.dead || (u?.charId && chars[u.charId]?.dead);
    return {key:k, label: u ? `${u.name}${charName? ' ‚Äî '+charName:''}${dead?' (dead)':''}` : k, dead: !!dead};
  });
  const myVote = votes[uid] || '';

  if (voting.open){
    help.textContent = 'Voting is OPEN. Choose one candidate:';
    list.innerHTML = display.map(d=>`
      <label class="vote-item">
        <input type="radio" name="voteChoice" value="${d.key}" ${myVote===d.key?'checked':''} ${d.dead?'disabled':''}/>
        <div>${d.label}</div>
      </label>
    `).join('') || '<div class="muted">No candidates yet.</div>';
    btn.disabled = false;
    tallyBox.innerHTML = '<span class="muted">Tally will appear when voting closes.</span>';
  }else{
    help.textContent = 'Voting is CLOSED. Final tally:';
    list.innerHTML = display.map(d=>`<div class="vote-item"><div>${d.label}</div></div>`).join('') || '<div class="muted">No candidates.</div>';
    btn.disabled = true;
    const tally = {};
    Object.entries(votes).forEach(([voter, choice])=>{
      const u = users[voter]; const aliveVoter = u && !u.dead && !(u.charId && chars[u.charId]?.dead);
      if (aliveVoter) tally[choice] = (tally[choice]||0)+1;
    });
    const tallyLines = display.map(d=>`‚Ä¢ ${d.label}: <b class="tally">${tally[d.key]||0}</b>`).join('<br>');
    tallyBox.innerHTML = tallyLines || 'No votes.';
  }
}
byId('castVoteBtn').addEventListener('click', async ()=>{
  const {room,name} = loadLocalIdentity();
  if (!room || !name) return;
  const uid = getUid(room,name);
  const state = await getRoomState(room);
  if (!state.voting?.open){ alert('Voting is not open.'); return; }
  const choice = document.querySelector('input[name="voteChoice"]:checked');
  if (!choice){ alert('Pick a candidate.'); return; }
  await db.ref(`rooms/${room}/state/voting/votes/${uid}`).set(choice.value);
  alert('Vote recorded.');
  refreshActive();
});

/* Clues (player) */
async function renderClues(){
  const room = localStorage.getItem('mb_room') || (byId('joinRoom').value||'').trim().toUpperCase();
  const list = byId('clueList');
  if (!room){ list.innerHTML = '<div class="muted">Join a room first.</div>'; return; }
  const snap = await db.ref(`rooms/${room}/clues`).get();
  if (!snap.exists()){ list.innerHTML = '<div class="muted">No clues seeded.</div>'; return; }
  const clues = Object.entries(snap.val()).filter(([id,c])=>c.revealed);
  if (!clues.length){ list.innerHTML = '<div class="muted">No clues revealed yet.</div>'; return; }
  list.innerHTML = clues.map(([id,c])=>`
    <article class="parchment">
      <div class="tag">Clue ${id}</div>
      <h4>${c.title}</h4>
      <div>${c.body}</div>
    </article>
  `).join('');
}
byId('refreshCluesBtn').addEventListener('click', renderClues);
document.getElementById('tab-clues').addEventListener('click', renderClues);

/* Admin */
let ADMIN_OK = false;
async function adminAuth(){
  const room = (byId('adminRoom').value||'').trim().toUpperCase();
  const adminPass = (byId('adminPass').value||'').trim();
  const out = byId('adminAuthStatus');
  try{
    const snap = await db.ref(`rooms/${room}/adminHash`).get();
    if (!snap.exists()) throw new Error('Room not found');
    const ok = (await hashSHA256(adminPass)) === snap.val();
    if (!ok) throw new Error('Incorrect admin password');
    ADMIN_OK = true;
    localStorage.setItem('mb_room_admin', room);
    localStorage.setItem('mb_is_admin', '1'); // mark this device as admin-unlocked
    out.innerHTML = `<span class="badge success">Admin unlocked</span>`;
    await refreshAdminAll();
  }catch(e){
    ADMIN_OK = false;
    out.innerHTML = `<span class="badge danger">Auth failed</span> ${e.message}`;
  }
}
byId('adminAuthBtn').addEventListener('click', adminAuth);
function currentAdminRoom(){ return (byId('adminRoom').value||localStorage.getItem('mb_room_admin')||'').toUpperCase(); }
async function refreshAdminAll(){
  await updateRoundGameVotingDisplays();
  await refreshPlayerDropdowns();
  await refreshCandidateSelectors();
  await renderAdminTally();
}

/* Lists render */
function renderLists(data){
  const chars = data||{};
  const entries = Object.entries(chars);
  const un = entries.filter(([id,c])=>!c.claimedBy).map(([id,c])=>`‚Ä¢ ${c.name}${c.dead?' (dead)':''}`).join("<br>") || '‚Äî';
  const cl = entries.filter(([id,c])=>c.claimedBy).map(([id,c])=>`‚Ä¢ <b>${c.name}</b> <span class="muted">‚Üí ${c.claimedBy}${c.dead?' (dead)':''}</span>`).join("<br>") || '‚Äî';
  byId('unclaimedBox').innerHTML = un;
  byId('claimedBox').innerHTML = cl;
}

let liveOff = null;
byId('loadRoomBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK){ byId('adminAuthStatus').innerHTML=`<span class="badge danger">Unlock Admin first</span>`; return; }
  const room = currentAdminRoom();
  const snap = await db.ref(`rooms/${room}/characters`).get();
  if (!snap.exists()){ byId('adminAuthStatus').innerHTML=`<span class="badge danger">Room not found</span>`; return; }
  renderLists(snap.val());
  await refreshAdminAll();
});

byId('watchRoomBtn').addEventListener('click', ()=>{
  if (!ADMIN_OK){ byId('adminAuthStatus').innerHTML=`<span class="badge danger">Unlock Admin first</span>`; return; }
  const room = currentAdminRoom();
  if (liveOff) { liveOff(); liveOff=null; }
  const ref = db.ref(`rooms/${room}`);
  const cb = ref.on('value', async snap=> {
    const data = snap.val()||{};
    renderLists(data.characters||{});
    await refreshAdminAll();
  });
  liveOff = ()=> ref.off('value', cb);
  byId('adminAuthStatus').innerHTML = `<span class="badge">Watching live‚Ä¶</span>`;
});

async function refreshPlayerDropdowns(){
  const room = currentAdminRoom();
  const usersSnap = await db.ref(`rooms/${room}/users`).get();
  const sel = byId('playerSelect');
  const candSel = byId('candidatePlayerSelect');
  const deadSel = byId('deadToggleSelect');
  sel.innerHTML = '<option value="">‚Äî select player ‚Äî</option>';
  candSel.innerHTML = '<option value="">‚Äî add candidate (claimed players) ‚Äî</option>';
  deadSel.innerHTML = '<option value="">‚Äî select claimed player ‚Äî</option>';
  if (!usersSnap.exists()) return;
  const users = usersSnap.val();
  for (const [uid,u] of Object.entries(users)){
    const opt = document.createElement('option'); opt.value = uid; opt.textContent = u.name;
    sel.appendChild(opt);
    const opt2 = document.createElement('option'); opt2.value = uid; opt2.textContent = u.name;
    candSel.appendChild(opt2);
    const opt3 = document.createElement('option'); opt3.value = uid; opt3.textContent = `${u.name}${u.dead?' (dead)':''}`;
    deadSel.appendChild(opt3);
  }
}
document.getElementById('tab-admin').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  await refreshAdminAll();
});

/* Assign roles */
byId('assignSpecialBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK){ byId('specialStatus').innerHTML=`<span class="badge danger">Unlock Admin</span>`; return; }
  const room = currentAdminRoom();
  const uid = byId('playerSelect').value;
  const role = byId('specialSelect').value || null;
  if (!uid){ byId('specialStatus').innerHTML=`<span class="badge danger">Pick a player</span>`; return; }
  await db.ref(`rooms/${room}/users/${uid}/specialRole`).set(role);
  byId('specialStatus').innerHTML = `<span class="badge success">Saved</span>`;
  await checkWinConditions(room);
});

/* Mark Dead/Alive */
byId('markDeadBtn').addEventListener('click', ()=> toggleDead(true));
byId('markAliveBtn').addEventListener('click', ()=> toggleDead(false));
async function toggleDead(dead){
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  const uid = byId('deadToggleSelect').value;
  if (!uid) return;
  const uSnap = await db.ref(`rooms/${room}/users/${uid}`).get();
  if (!uSnap.exists()) return;
  const u = uSnap.val();
  await db.ref(`rooms/${room}/users/${uid}/dead`).set(dead);
  if (u.charId) await db.ref(`rooms/${room}/characters/${u.charId}/dead`).set(dead);
  await renderAdminTally();
  await updateRoundGameVotingDisplays();
  await checkWinConditions(room, dead ? `Marked ${u.name} dead.` : `Marked ${u.name} alive.`);
}

/* Game / Round / Voting Controls */
async function getState(room){ return (await db.ref(`rooms/${room}/state`).get()).val()||{}; }

async function updateRoundGameVotingDisplays(){
  const room = currentAdminRoom();
  const state = await getState(room);
  byId('adminRoundDisplay').value = state.round || 1;
  byId('votingStatusDisplay').value = state.voting?.open ? 'OPEN' : (state.voting?.closed ? 'CLOSED' : '‚Äî');
  byId('gameStateDisplay').value = state.gameStarted ? 'STARTED' : 'WAITING';
}

byId('startGameBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  const state = await getState(room);
  await db.ref(`rooms/${room}/state`).set({
    gameStarted:true,
    round: state.round || 1,
    voting: { open:false, closed:false, candidates:null, votes:null, endsAt:null }
  });
  await updateRoundGameVotingDisplays();
  popup('Game Started', 'Players now see objectives, notes, and Mob Justice.');
});

byId('stopGameBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  const state = await getState(room);
  await db.ref(`rooms/${room}/state`).set({
    gameStarted:false,
    round: state.round || 1,
    voting: { open:false, closed:false, candidates:null, votes:null, endsAt:null }
  });
  await updateRoundGameVotingDisplays();
  popup('Back to Waiting', 'Players now see only character and role info.');
});

byId('nextRoundBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  const state = await getState(room);
  const next = (state.round||1) + 1;
  await db.ref(`rooms/${room}/state`).set({
    gameStarted: state.gameStarted || false,
    round: next,
    voting: { open:false, closed:false, candidates:null, votes:null, endsAt:null }
  });
  await updateRoundGameVotingDisplays();
  await renderAdminTally();
  await checkWinConditions(room, `Advanced to Round ${next}.`);
});

/* Voting Open/Close/Clear and Timer */
byId('openVotingBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  const state = await getState(room);
  await db.ref(`rooms/${room}/state/voting`).set({
    open:true, closed:false,
    candidates: state.voting?.candidates || null,
    votes: state.voting?.votes || null,
    endsAt:null
  });
  await updateRoundGameVotingDisplays(); await renderAdminTally();
});

byId('closeVotingBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  await closeVotingAndResolve(room, true);
});

byId('clearVotingBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  await db.ref(`rooms/${room}/state/voting`).set({ open:false, closed:false, candidates:null, votes:null, endsAt:null });
  await updateRoundGameVotingDisplays(); await refreshCandidateSelectors(); await renderAdminTally();
});

byId('start5minVoteBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  const endsAt = Date.now() + 5*60*1000;
  const state = await getState(room);
  await db.ref(`rooms/${room}/state/voting`).set({
    open:true, closed:false,
    candidates: state.voting?.candidates || null,
    votes: state.voting?.votes || null,
    endsAt
  });
  await updateRoundGameVotingDisplays(); await renderAdminTally();
  scheduleAutoClose(room, endsAt);
});

/* Candidate add/remove */
async function refreshCandidateSelectors(){
  const room = currentAdminRoom();
  const state = await getState(room);
  const candidates = state.voting?.candidates || {};
  const usersSnap = await db.ref(`rooms/${room}/users`).get();
  const charsSnap = await db.ref(`rooms/${room}/characters`).get();
  const users = usersSnap.exists()? usersSnap.val() : {};
  const chars = charsSnap.exists()? charsSnap.val() : {};
  const removeSel = byId('removeCandidateSelect');
  removeSel.innerHTML = '<option value="">‚Äî remove candidate ‚Äî</option>';
  for (const key of Object.keys(candidates||{})){
    const u = users[key]; const charName = u && u.charId && chars[u.charId] ? chars[u.charId].name : '';
    const opt = document.createElement('option');
    opt.value = key; opt.textContent = u ? `${u.name}${charName? ' ‚Äî '+charName:''}` : key;
    removeSel.appendChild(opt);
  }
}
byId('addCandidateBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  const uid = byId('candidatePlayerSelect').value;
  if (!uid) return;
  await db.ref(`rooms/${room}/state/voting/candidates/${uid}`).set(true);
  await refreshCandidateSelectors(); await renderAdminTally();
});
byId('removeCandidateBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  const uid = byId('removeCandidateSelect').value;
  if (!uid) return;
  await db.ref(`rooms/${room}/state/voting/candidates/${uid}`).remove();
  const votesSnap = await db.ref(`rooms/${room}/state/voting/votes`).get();
  if (votesSnap.exists()){
    const votes = votesSnap.val();
    for (const [voter, choice] of Object.entries(votes)){
      if (choice === uid) await db.ref(`rooms/${room}/state/voting/votes/${voter}`).remove();
    }
  }
  await refreshCandidateSelectors(); await renderAdminTally();
});

/* Admin Tally */
async function renderAdminTally(){
  const room = currentAdminRoom();
  const state = await getState(room);
  const voting = state.voting || {};
  const [usersSnap, charsSnap] = await Promise.all([
    db.ref(`rooms/${room}/users`).get(),
    db.ref(`rooms/${room}/characters`).get()
  ]);
  const users = usersSnap.exists()? usersSnap.val(): {};
  const chars = charsSnap.exists()? charsSnap.val(): {};
  const candidates = voting.candidates || {};
  const votes = voting.votes || {};
  const display = Object.keys(candidates).map(k=>{
    const u = users[k]; const charName = u && u.charId && chars[u.charId] ? chars[u.charId].name : '';
    return {key:k, label: u ? `${u.name}${charName? ' ‚Äî '+charName:''}` : k};
  });
  const alive = Object.entries(users).filter(([uid,u])=>{
    const dead = u.dead || (u.charId && chars[u.charId]?.dead);
    return !dead;
  }).length;
  const tally = {};
  Object.entries(votes).forEach(([voter, choice])=>{
    const u = users[voter]; const aliveVoter = u && !u.dead && !(u.charId && chars[u.charId]?.dead);
    if (aliveVoter) tally[choice] = (tally[choice]||0)+1;
  });
  const lines = display.map(d=>`‚Ä¢ ${d.label}: <b class="tally">${tally[d.key]||0}</b>`).join('<br>');
  byId('adminTallyBox').innerHTML = (alive? `<div class="muted">Alive voters: ${alive}</div>` : '') + (lines || 'No votes yet.');
}

/* Auto close voting */
function scheduleAutoClose(room, endsAt){
  const ms = Math.max(0, endsAt - Date.now());
  setTimeout(async ()=>{
    const state = await getState(room);
    if (state.voting?.open && state.voting.endsAt && Date.now() >= state.voting.endsAt){
      await closeVotingAndResolve(room, false);
    }
  }, ms + 1000);
}

/* Close vote, resolve, eliminate (‚â•50% of alive), popup */
async function closeVotingAndResolve(room, manual){
  const state = await getState(room);
  const voting = state.voting || {};
  if (!voting.open) return;
  await db.ref(`rooms/${room}/state/voting/open`).set(false);
  await db.ref(`rooms/${room}/state/voting/closed`).set(true);

  const [usersSnap, charsSnap] = await Promise.all([
    db.ref(`rooms/${room}/users`).get(),
    db.ref(`rooms/${room}/characters`).get()
  ]);
  const users = usersSnap.exists()? usersSnap.val(): {};
  const chars = charsSnap.exists()? charsSnap.val(): {};
  const votes = voting.votes || {};
  const aliveUsers = Object.entries(users).filter(([uid,u])=> !(u.dead || (u.charId && chars[u.charId]?.dead)));
  const aliveCount = aliveUsers.length;

  const tally = {};
  for (const [voter, choice] of Object.entries(votes)){
    const u = users[voter];
    const aliveVoter = u && !u.dead && !(u.charId && chars[u.charId]?.dead);
    if (aliveVoter) tally[choice] = (tally[choice]||0)+1;
  }
  let bestKey = null, bestCount = -1;
  Object.entries(tally).forEach(([k,c])=>{ if (c>bestCount){ bestKey=k; bestCount=c; }});
  const needed = Math.ceil(aliveCount * 0.5);
  let resultHtml = `<div>Alive voters: <b>${aliveCount}</b> ‚Ä¢ Threshold to eliminate: <b>${needed}</b></div><br>`;
  for (const [k,c] of Object.entries(tally)){
    const u = users[k];
    const label = u ? u.name : k;
    resultHtml += `‚Ä¢ ${label}: <b class="tally">${c}</b><br>`;
  }
  if (bestKey && bestCount >= needed){
    const u = users[bestKey];
    if (u){
      await db.ref(`rooms/${room}/users/${bestKey}/dead`).set(true);
      if (u.charId) await db.ref(`rooms/${room}/characters/${u.charId}/dead`).set(true);
      resultHtml += `<br><b>Eliminated:</b> ${u.name} (by vote)`;
    }
  }else{
    resultHtml += `<br><b>No elimination.</b>`;
  }
  popup('Mob Justice ‚Äî Results', resultHtml);
  await renderAdminTally();
  await checkWinConditions(room);
}

/* Win conditions */
async function checkWinConditions(room, extraMsg){
  const [usersSnap, charsSnap, stateSnap] = await Promise.all([
    db.ref(`rooms/${room}/users`).get(),
    db.ref(`rooms/${room}/characters`).get(),
    db.ref(`rooms/${room}/state`).get()
  ]);
  if (!usersSnap.exists()) return;
  const users = usersSnap.val();
  const chars = charsSnap.exists()? charsSnap.val(): {};
  const state = stateSnap.exists()? stateSnap.val(): {round:1};

  const aliveUsers = Object.values(users).filter(u=> !(u.dead || (u.charId && chars[u.charId]?.dead)));
  const aliveVamps = aliveUsers.filter(u=> ['Elder Vampire','Lesser Vampire'].includes(u.specialRole));
  const aliveNonVamps = aliveUsers.filter(u=> !['Elder Vampire','Lesser Vampire'].includes(u.specialRole));

  if (aliveVamps.length === 0){
    popup('Village Victory', `<div>The Elder and Lesser vampires are dead. The village prevails!${extraMsg? `<br><br><i>${extraMsg}</i>`:''}</div>`);
    return;
  }
  if (aliveVamps.length >= aliveNonVamps.length || (state.round>4 && aliveVamps.length>0)){
    popup('Vampires Triumph', `<div>The night belongs to fangs and shadow.${extraMsg? `<br><br><i>${extraMsg}</i>`:''}</div>`);
  }
}

/* CSV Import (Admin) */
function parseCSV(text){
  const rows=[]; let cur=''; let row=[]; let inq=false;
  for (let i=0;i<text.length;i++){
    const ch=text[i], nxt=text[i+1];
    if (ch==='\"'){
      if (inq && nxt==='\"'){ cur+='\"'; i++; }
      else inq=!inq;
    }else if (ch===',' && !inq){
      row.push(cur); cur='';
    }else if ((ch==='\n' || ch==='\r') && !inq){
      if (cur.length||row.length){ row.push(cur); rows.push(row); cur=''; row=[]; }
      if (ch==='\r' && nxt==='\n') i++;
    }else cur+=ch;
  }
  if (cur.length||row.length) { row.push(cur); rows.push(row); }
  return rows;
}

byId('importCharsBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  const file = byId('csvChars').files[0];
  if (!file){ byId('csvStatus').textContent='Select a characters CSV.'; return; }
  const txt = await file.text();
  const rows = parseCSV(txt).filter(r=>r.length>=1);
  const chars={}; let i=0;
  for (const r of rows){
    const name=(r[0]||'').trim(); if (!name) continue;
    const desc=(r[1]||'').trim()||null;
    const id='c_'+(i++).toString().padStart(3,'0');
    chars[id]={name: desc ? `${name} ‚Äî ${desc}` : name, desc, claimedBy:null, claimedAt:null, dead:false};
  }
  if (!Object.keys(chars).length){ byId('csvStatus').textContent='No valid rows found.'; return; }
  await db.ref(`rooms/${room}/characters`).set(chars);
  byId('csvStatus').textContent='Characters imported.';
  await renderAdminTally(); await refreshPlayerDropdowns();
});

byId('useDefaultCharsBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  const chars={}; DEFAULT_CHAR_OBJS.forEach((o,i)=>{
    const id='c_'+i.toString().padStart(3,'0');
    const combined = o.desc ? `${o.name} ‚Äî ${o.desc}` : o.name;
    chars[id]={name:combined, desc:o.desc||null, claimedBy:null, claimedAt:null, dead:false};
  });
  await db.ref(`rooms/${room}/characters`).set(chars);
  byId('csvStatus').textContent='Default characters loaded.';
  await renderAdminTally(); await refreshPlayerDropdowns();
});

byId('importCluesBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  const file = byId('csvClues').files[0];
  if (!file){ byId('csvStatus').textContent='Select a clues CSV.'; return; }
  const txt = await file.text();
  const rows = parseCSV(txt).filter(r=>r.length>=3);
  const clues={};
  for (const r of rows){
    const id=(r[0]||'').trim(); const title=(r[1]||'').trim(); const body=(r[2]||'').trim();
    if (!id || !title || !body) continue;
    clues[id]={title, body, revealed:false};
  }
  if (!Object.keys(clues).length){ byId('csvStatus').textContent='No valid clue rows found.'; return; }
  await db.ref(`rooms/${room}/clues`).set(clues);
  byId('csvStatus').textContent='Clues imported.';
});

byId('useDefaultCluesBtn').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  const room = currentAdminRoom();
  const clues={}; DEFAULT_CLUES.forEach(c=> clues[c.id]={title:c.title, body:c.body, revealed:false});
  await db.ref(`rooms/${room}/clues`).set(clues);
  byId('csvStatus').textContent='Default clues loaded.';
});

/* Candidate list (Admin) refresh hook */
document.getElementById('tab-admin').addEventListener('click', async ()=>{
  if (!ADMIN_OK) return;
  await refreshCandidateSelectors();
  await renderAdminTally();
});

/* Collapse UI to Active for players with a character */
function collapseToActiveOnly(){
  const isAdminUnlocked = localStorage.getItem('mb_is_admin') === '1';
  // Hide tabs for regular players; show tabs for admin device
  if (!isAdminUnlocked) byId('topTabs').classList.add('hidden');
  // Show only the Active panel
  document.getElementById('panel-active').hidden = false;
  ['panel-host','panel-join','panel-clues','panel-admin'].forEach(id=>{
    const el = document.getElementById(id); if (el) el.hidden = true;
  });
}

/* Prefill from cookies; show active if already assigned */
(function(){
  const r = getCookie('mb_room'); const n = getCookie('mb_name');
  if (r) byId('joinRoom').value = r;
  if (n) byId('realName').value = n;
})();
document.addEventListener('DOMContentLoaded', ()=>{
  if (localStorage.getItem('mb_charId')) collapseToActiveOnly();
  refreshActive();
});
</script>
</body>
</html>
